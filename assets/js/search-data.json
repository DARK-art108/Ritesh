{
  
    
        "post0": {
            "title": "Distributed Training in TensorFlow with AI Platform & Docker",
            "content": "Jupyter Notebooks are a great way to present your code offering a good level of interactivity, transparency, and reproducibility. However, operating with a Jupyter Notebook environment can get very challenging if you are working your way through large-scale training workflows as is common in deep learning. . If you are conducting large-scale training it is likely that you are using a powerful remote machine via SSH access. So, even if you are not using Jupyter Notebooks, problems like SSH pipe breakage, network teardown, etc. can easily occur. Consider using a powerful virtual machine on Cloud as your remote. The problem gets far worse when there’s a connection loss but you somehow forget to turn off that virtual machine to stop consuming its resources. You get billed for practically nothing when the breakdown happens until and unless you have set up some amount of alerts and fault tolerance. . To resolve these kinds of problems, we would want to have the following things in the pipeline: . A training workflow that is fully managed by a secure and reliable service with high availability. | The service should automatically provision and de-provision the resources we would ask it to configure allowing us to only get charged for what’s been truly consumed. | The service should also be very flexible. It must not introduce too much technical debt into our existing pipelines. | . In this post, we are going to consider all of these factors and will implement them using a service called AI Platform (provided by GCP) and Docker. We will use TensorFlow and Keras to handle distributed training to develop an image classification model capable of classifying cats and dogs. Apart from deep learning-related knowledge, a bit of familiarity would be needed to fully understand this post. . All of the code developed for this post can be found here. We won’t be covering the entire codebase, instead, we will focus on the most important bits. . If you are like me, who have lost sleep over the very thought of the aforementioned problem, you will likely find this tutorial a good starting point to get around it. . Environment setup . You will need to have Docker, command-line GCP (Google Cloud Platform) tools like gcloud, and TensorFlow (2.x) installed if you are on a local machine. But if you have a billing-enabled GCP project it’s possible to get started without any significant setup. . We will use a cheap AI Platform Notebook instance as our staging machine which we will use to build our custom Docker image, push it to Google Container Registry (GCR), and submit a training job to AI Platform. Additionally, we will use this instance to create TensorFlow Records (TFRecords) from the original dataset (Cats vs. Dogs in this case) and upload them to a GCS Bucket. AI Platform notebooks come pre-configured with many useful Python libraries, Linux packages like docker, and also the command-line GCP tools like gcloud. . Note: I used an n1-standard-4 instance with TensorFlow 2.4 as the base image which costs $0.141 hourly. . Notes on the task, data pipeline, and training . Task . As mentioned earlier, we will be training an image classification model on the Cats vs. Dogs dataset which is a moderate-sized dataset. The learning problem is a binary classification task. . Data pipeline . For setting up our data pipeline, we will first create shards of TFRecords from the original dataset. Each of the shards will contain batches of preprocessed images and their labels. This has an advantage. When we would load these shards back for training, we won’t need to do any preprocessing giving us a slight performance boost. Figure 1 demonstrates our TFRecords’ creation workflow. . . Figure 1: Schematics of our TFRecord’s creation process. As you might have already noticed that we have also thrown in another component in the mix -- a GCS Bucket. We would need to store our data on a Google Cloud Storage (GCS) Bucket since the training code won’t be executed locally. We could have used other bucket services (like AWS S3) here but TensorFlow has very unified integrations with GCS Buckets, hence. We will be using the same GCS Bucket to store our trained model and also TensorBoard logs. The total cost to store all of these will be about $1.20. . You are welcome to check out the corresponding code here. In order to streamline the TFRecords’ creation and upload process we will make use of a little shell script: . echo &quot;Uploading TFRecords to Storage Bucket...&quot; echo gs://${BUCKET_NAME} python ../trainer/create_tfrecords.py gsutil -m cp -r train_tfr gs://${BUCKET_NAME} gsutil -m cp -r validation_tfr gs://${BUCKET_NAME} gsutil ls -lh gs://${BUCKET_NAME} . After creating the TFRecords we simply copy them over to a previously created GCS Bucket. You can create one by executing the following: gsutil mb ${BUCKET_NAME}. . Training . As for the training pipeline, we will follow the steps below: . Load the TFRecords from GCS using CPU in a parallelized way using tf.data.Dataset.map() and feed batches of data to our model. For performance, we will also prefetch several future batches of data so that our model does not have to wait for the data to consume. Our data loader is present here in this script. | We will be using a pre-trained model to unleash the power of transfer learning. In particular, we will be using the DenseNet121 model that is available inside tf.keras.applications. | We will be training our model inside the tf.distribute.MirroredStrategy scope for distributed training. This strategy is applicable when we have a single host containing multiple GPUs. We will also be using mixed-precision training to speed up the process. The code for realizing this is here. | . The training will take place on a remote machine fully managed by AI Platform. . So far, we have discussed the utilities for creating TFRecords, loading them, and building and training our model. Here’s how the code is structured in the GitHub repository mentioned at the beginning of the post: . ├── Dockerfile ├── README.md ├── config.yaml ├── scripts │ ├── train_cloud.sh │ ├── train_local.sh │ └── upload_tfr.sh └── trainer ├── config.py ├── create_tfrecords.py ├── data_loader.py ├── model_training.py ├── model_utils.py ├── task.py └── tfr_utils.py . Next, we will be reviewing how Docker fits into all these. From there on, we will have all the recipes set up to kickstart model training. . Fitting in Docker . To submit custom training jobs to AI Platform, we need to package our code inside a Docker image. So, let’s start with that. . To build a Docker image, we first need to define a Dockerfile specifying how it should itself up. Google Container Registry (GCR) provides CUDA-configured TensorFlow containers that we can use to build custom ones. In our case, we extend one such container. Our Dockerfile looks like so: . # Use an existing CUDA-configured TensorFlow container FROM gcr.io/deeplearning-platform-release/tf2-gpu.2-4 WORKDIR /root # Update TensorFlow to the latest version (2.4.1 at the # time of writing). RUN pip install -U tensorflow # Copies the trainer code to the docker image. COPY trainer/config.py ./trainer/config.py COPY trainer/data_loader.py ./trainer/data_loader.py COPY trainer/model_utils.py ./trainer/model_utils.py COPY trainer/model_training.py ./trainer/model_training.py COPY trainer/task.py ./trainer/task.py # Set up the entry point to invoke the trainer. ENTRYPOINT [&quot;python&quot;] CMD [&quot;trainer/task.py&quot;] . After we have defined the Dockerfile, we can proceed to build it and do a round of model training by locally running it. . Building and locally running our container . We will be using GCR to manage the lifecycle of our container. To build a Docker container, one must provide a correct Image URI (Uniform Resource Identifier) and it depends on the platform you are using for managing your container. In our case, that is GCR. . For GCR, the format of the image goes like the following: gcr.io/${PROJECT_ID}/${IMAGE_REPO_NAME}:${IMAGE_TAG}, where PROJECT_ID is the ID of your GCP project and IMAGE_REPO_NAME and IMAGE_TAG are identifiers. . We then build our image and locally run it: . $ docker build -f Dockerfile -t ${IMAGE_URI} ./ $ docker run ${IMAGE_URI} trainer/task.py --bucket ${BUCKET_NAME} --train-pattern ${TRAIN_FILES} --valid-pattern ${VALIDATION_FILES} . To make the process cleaner, we can create a shell script and put all the instructions inside it. You can follow this one to get an idea. . The first time it’s run, it’s going to take a while. But after that, all the consequent runs will use the cached resources to speed up the build. The local Docker daemon (dockerd) will first read our Dockerfile and after getting to the entry point, it will parse all the command-line arguments we provided to task.py. task.py just takes all the command-line arguments and starts the model training. TRAIN_FILES and VALIDATION_FILES are patterns to the TFRecords residing inside a GCS Bucket and they look like so - . TRAIN_FILES=gs://${BUCKET_NAME}/train_tfr/*.tfrec VALIDATION_FILES=gs://${BUCKET_NAME}/validation_tfr/*.tfrec . If everything goes well, then, after a while, you should be able to see that our model has started training: . . Figure 2: Docker build. . Figure 3: Local training logs. The local Docker run is a way for us to ensure our code is running fine without any hiccups. So, it’s advisable to stop the local run after you have ensured the model is able to start training. With this, we are now ready to push our custom Docker image to GCR, and submit a training job to AI Platform. . Submitting a training job . For this step, we need to add two more lines of code: . After building our Docker image, we need to push it to GCR so that AI Platform can pull it to run model training. | Submit a training job to AI Platform. | . So, let’s put these pieces together: . # Build and push the docker image $ docker build -f Dockerfile -t ${IMAGE_URI} ./ $ docker push ${IMAGE_URI} # Submit job $ gcloud ai-platform jobs submit training ${JOB_NAME} --region ${REGION} --master-image-uri ${IMAGE_URI} --config ./config.yaml -- trainer/task.py --bucket ${BUCKET_NAME} --train-pattern ${TRAIN_FILES} --valid-pattern ${VALIDATION_FILES} . Reviewing what’s going on with the gcloud command, we have: . region, that informs AI Platform about the region to be used for the training process. This very region is also going to be used to provision resources such as GPUs. If GPUs are to be used then it’s important to pass a region that has that support. You can know the regions that have this support from here. | master-image-uri is the URI of our custom Docker image. | Via config, we provide a specification of the kind of machine we want to use for training. This specification is provided using a YAML file and ours looks like so: . trainingInput: scaleTier: CUSTOM # Configure a master worker with 2 V100 GPUs masterType: n1-standard-8 # Specify the base machine type masterConfig: acceleratorConfig: count: 2 type: NVIDIA_TESLA_V100 . The advantage of using specifications like this lies in the flexibility it provides. The gcloud ai-platform jobs submit training command has a scale-tier option through which we can pass a pre-defined machine configuration. But let’s say we want to train using multiple machines - 1 master, 3 workers, and 3 parameter servers each having different GPU and CPU configurations. The pre-defined values won’t cut here and this is where we can take the advantage of custom specifications. You can check here to know the different machine types and configurations that can be provided to AI Platform. . | . . Important: We are using V100 GPUs because they come with Tensor cores and that is a must-have to take the advantage of mixed-precision training. We could have used other GPUs like T4, A100 as well that fit this criterion. . We have already discussed the part that follows config so we will not be reviewing that here. If the job submission is successful you should see an entry for it on the GCP console: . . Figure 4: AI Platform training job list. On the extreme right, you would notice an option called View Logs that lets us monitor our training. It’s incredibly useful to have all of your training logs stored somewhere safe without making any effort. Logging for an AI Platform training job is managed by Cloud Logging. Here’s how mine looks like: . . Figure 5: Training logs. Notice the neat search filter query. After training is complete, we can verify if all the necessary artifacts were stored inside our GCS Bucket: . . Figure 6: SavedModel file and TensorBoard logs. In our training script, we had set up the TensorBoard callback to keep track of the training progress. You can check one such log here online on tensorboard.dev. Inspecting into it, we can see that our model’s been trained well, as the validation accuracy has stabilized: . . Figure 7: Accuracy plot. As an effective practitioner, It’s important to be aware of the costs and ensure maximization of resource utilization. Now that we were able to successfully complete our model training, let’s discuss these aspects in the next and final section of the post. . Delving deep into training costs and resource utilization . AI Platform provides a number of useful metrics for the training jobs. Each job has a separate dashboard that makes it super easy to keep track of its statistics such as total training time, average resource utilization, etc. . First, we have high-level information about the job: . . Figure 8: High-level information about a training job. We can see that the job takes about 22 minutes to complete, and this includes the provisioning of resources, completing the model training, and de-provisioning the resources. We then see the total ML units consumed to run our job. The cost for this translates to: . 1.79 (Consumed ML units) $ times$ USD 0.49 = USD 0.8771 . You can refer to this document that details the cost calculation scheme. GCP also provides a handy estimated cost calculator that you can find here. . So far our costs are: USD 0.141 (AI Platform Notebook) + USD 1.20 (GCS) + USD 0.8771 (training job) = USD 2.2181. Let’s compare this to an AI Platform Notebook instance equipped with the similar configurations as the one we used for training: . . Figure 9: Cost for an AI Platform Notebook with 2 V100 GPUs with n1-standard-8. Coming to CPU utilization, we have some room for improvement it seems: . . Figure 10: CPU utilization of our training resources. The overall GPU utilization has a few spikes which might need some more inspections in the future: . . Figure 11: GPU utilization of our training resources. Conclusion . We have covered quite a lot of ground in this post. I hope by now you have an idea of how to combine tools like Docker, AI Platform to manage your large-scale training workflows in a more cost-effective and scalable way. As a next step, you could take the trained model from AI Platform and deploy the model using it. AI Platform predict jobs make it easier to expose models via REST API-like services that are fully managed by AI Platform offering things like autoscaling, authorization, monitoring, etc. If you&#39;d like to try it out yourself, I encourage you to check out the code of this post on GitHub. You are also welcome to checkout TensorFlow Cloud that provides a set of tools making it easier to perform large-scale training with GCP. . Acknowledgements . I am thankful to Karl Weinmeister for his comments on the initial draft of this post. Also, thanks to the ML-GDE program for providing generous GCP support without which I couldn’t have executed the experiments. .",
            "url": "https://sayak.dev/distributed-training/",
            "relUrl": "/distributed-training/",
            "date": " • Apr 6, 2021"
        }
        
    
  
    
        ,"post1": {
            "title": "Building and Installing OpenCV 4.5.0 on an M1 Mac",
            "content": "This post shows how to build and install OpenCV 4.5.0 on a MacBook Pro that comes with an M1 chip. Yes, you guessed it right - as of January 01, 2021, there’s no pre-compiled OpenCV binary compatible with this MacBook Pro variant. So, open up a terminal and get started! . Here&#39;s a brief summary of the configuration of my MacBook - . . Note: The following steps should run well on an M1 MacBook Air too. . Install Xcode and Homebrew . We start by executing sudo xcodebuild -license from a terminal. . When you execute the above command, you would need to accept the Xcode license. Then, in order to make use of Apple command line tools, we need to install it - sudo xcode-select --install. . Homebrew manages packages on a Mac. In order to install it execute the following - /usr/bin/ruby -e &quot;%(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;. . You would want to add the command brew after the installation is complete. To do so, execute the following - nano ~/.zshrc . Then insert export PATH=$PATH:/opt/homebrew/bin into it and press Ctrl + X from your keyboard. Then execute source ~/.zshrc from the terminal. . Note that the exact path to Homebrew might be different for your system, so please double check that. . Next up, we install a few system-level utilities required by OpenCV on a Mac. . Install conda . My favorite Python virtual environment manager is virtualenv. Unfortunately, it does not play out that well with the new M1 chip. This is mostly because the pip-installable packages often break during their installations on the chip. This is why conda, specifically its miniforge distribution is the recommended package manager for a Mac shipped with M1. You can install it from here. This installs Python 3.8. . After the installation is complete, please create a new Python virtual environment by executing conda create --name &lt;environment_name&gt;. Then activate it by running conda activate &lt;environment_name&gt;. . Running conda install -y python==3.8.6 will install a few common Python packages for you. I highly recommend running this. . Install NumPy . NumPy is needed by OpenCV. So, we need to install it before we build and install OpenCV. Apple provides a numpy wheel that is compatible with the M1 chip. Follow the steps below to install it - . % wget https://github.com/apple/tensorflow_macos/releases/download/v0.1alpha0/tensorflow_macos-0.1alpha0.tar.gz % tar xvf tensorflow_macos-0.1alpha0.tar.gz % cd tensorflow_macos/arm64 % pip install --upgrade --no-dependencies --force numpy-1.18.5-cp38-cp38-macosx_11_0_arm64.whl % cd ~ . . Note: Be sure to activate your conda environment before doing the pip-install. . Compile OpenCV . First, let&#39;s download the OpenCV and OpenCV extended module files and prepare them for compilation. . % wget -O opencv.zip https://github.com/opencv/opencv/archive/4.5.0.zip % wget -O opencv_contrib.zip https://github.com/opencv/opencv_contrib/archive/4.5.0.zip % unzip opencv.zip % unzip opencv_contrib.zip % cd opencv-4.5.0 % mkdir build &amp;&amp; cd build . Now, we are all set to fire the cmake command that would build OpenCV for us. Let’s review it briefly - . % cmake -DCMAKE_SYSTEM_PROCESSOR=arm64 -DCMAKE_OSX_ARCHITECTURES=arm64 -DWITH_OPENJPEG=OFF -DWITH_IPP=OFF -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=/usr/local -D OPENCV_EXTRA_MODULES_PATH=/Users/sayakpaul/Downloads/opencv_contrib-4.5.0/modules -D PYTHON3_EXECUTABLE=/Users/sayakpaul/miniforge3/envs/dev/bin/python3 -D BUILD_opencv_python2=OFF -D BUILD_opencv_python3=ON -D INSTALL_PYTHON_EXAMPLES=ON -D INSTALL_C_EXAMPLES=OFF -D OPENCV_ENABLE_NONFREE=ON -D BUILD_EXAMPLES=ON .. . As per this issue comment, DCMAKE_SYSTEM_PROCESSOR, DCMAKE_OSX_ARCHITECTURES, DWITH_OPENJPEG, and DWITH_IPP are needed to be set during the compilation step. Also, please pay attention to the following arguments - OPENCV_EXTRA_MODULES_PATH and PYTHON3_EXECUTABLE. For these two arguments, you would want to first determine the paths and then supply them accordingly. . Now, before you run the above cmake command, activate the conda environment you created in an earlier step (conda activate &lt;environment_name&gt;) if you haven’t already. The compilation took ~3 minutes for me and it should produce outputs like so - . . Next, we launch the make command - make -j8. With all the eight cores (j8 stands for eight cores here) chugging along, this step took ~8 minutes for me. You can adjust the j option with respect to the hardware available. After it’s done you should get an output like so - . . The final step here is to execute - sudo make install. It should take just a few seconds to complete execution. Upon successful completion, you should get an output like so - . . Sym-link OpenCV 4 on macOS to virtual environment site-packages . To do this, we first need to locate the .so file generated during the compilation step. We can do this with the mdfind command - . % mdfind cv2.cpython /.../opencv-4.5.0/build/lib/python3/cv2.cpython-38-darwin.so /usr/local/lib/python3.8/site-packages/cv2/python-3.8/cv2.cpython-38-darwin.so ... . Please note that I obfuscated some parts of the outputs for privacy reasons. In the above output, we can see the absolute locations for the .so files that were generated. Now, we need to execute the following to sym-link one of the .so files in our current Python virtual environment - . % cd /.../miniforge3/envs/dev/lib/python3.8/site-packages % ln -s /usr/local/lib/python3.8/site-packages/cv2/python-3.8/cv2.cpython-38-darwin.so cv2.so . Please double-check the paths before executing the commands. . And that’s it! . You can test the installation by executing the following - . % conda activate &lt;environment_name&gt; (if you haven&#39;t already) % python &gt;&gt;&gt; import cv2 &gt;&gt;&gt; cv2.__version__ . It should print &#39;4.5.0&#39;. . References . Install OpenCV 4 on macOS | TensorFlow 2.4 on Apple Silicon M1 : installation under Conda environment | .",
            "url": "https://sayak.dev/install-opencv-m1/",
            "relUrl": "/install-opencv-m1/",
            "date": " • Jan 1, 2021"
        }
        
    
  
    
        ,"post2": {
            "title": "A Battle of Text Detectors for Mobile Deployments: CRAFT vs. EAST",
            "content": "In the previous post, we saw how to convert the pre-trained CRAFT model from PyTorch to TensorFlow Lite (TFLite) and run inference with the converted TFLite model. In this post, we will be comparing the TFLite variants of the CRAFT model to another text detection model - EAST. The objective of this post is to provide a comparative study between these two models with respect to various deployment-specific pointers such as inference latency, model size, performance on dense text regions, and so on. Text detection continues to be a very important use-case across many verticals. So we hope this post will serve as a systematic guide for developers that are interested to explore on-device text detection models. . Precisely, we will be comparing the two models on the basis of the following pointers which we think are very crucial when it comes to deploying them out in the wild - . Visual Inspection of Performance | Model Size | Inference Latency | Memory Usage | . . Important: If you are interested to know about the conversion process and inference pipelines of the models, please refer to these notebooks - CRAFT and EAST. The pre-converted models are available on TensorFlow Hub - CRAFT and EAST. . Benchmark Setup . We used the TensorFlow Lite Benchmark tool in order to gather results on inference latency and memory usage of the models with Redmi K20 Pro as the target device. We chose a mobile device for this purpose because text detection is a pretty prevalent recipe of many mobile applications such as Google Lens. . In order to make the comparisons fair, we consider the two models with three different image resolutions - 320x320, 640x416, and 1200x800. For each of these resolutions, we consider two different post-training quantization schemes - dynamic-range and float16. The CRAFT model conversion is not yet supported in the integer variant, hence we do not consider integer quantization (but the EAST model does support it). . Visual Inspection of Performance . In this setting, we run both of the models and their different variants (dynamic-range and float16 quantized) on a sample image that has dense text regions, and then we visualize the results. We observed that both of these models perform fairly well on images having lighter text regions. Here’s the sample image we used for the purpose - . . Image is taken from the SROIE dataset. Time to detect some texts! . CRAFT - 320x320 Dynamic-Range &amp; float16 . In the dynamic-range quantization setting, we can see the model misses out on some text blocks. . . Inference results from the 320x320 dynamic-range and float16 quantized CRAFT models. With increased numerical precision i.e. float16, we can clearly see quite a bit of improvement in the results. It’s important to note that this improvement comes at the cost of increased model size. . Next up, we apply the same steps to the EAST model. . EAST - 320x320 Dynamic-Range &amp; float16 . EAST apparently performs better than CRAFT under dynamic-range quantization. If we look closely, it appears that the CRAFT model produces far fewer overlaps in the detections compared to EAST. On the other hand, the EAST model is able to detect more text blocks. When developing practical applications with text detectors, it often becomes a classic case of precision-recall trade-offs like the one we are currently seeing. So, you would want to consider the application-specific needs in order to decide the level of trade-off to be achieved there. . . Inference results from the 320x320 dynamic-range and float16 quantized EAST models. With increased precision, the above-mentioned points still hold, i.e. the number of overlaps being way higher for the EAST model than they are in the CRAFT equivalent. In this setting (float16 quantization), superiority in the performance of the CRAFT model is quite evident in regards to the EAST model. . As different applications may use different image resolutions we decided to test the performance of the models on larger dimensions as well. This is what we are going to see next. . CRAFT - 640x416 Dynamic-Range &amp; float16 . On an increased resolution, the CRAFT model performs pretty well - . . Inference results from the 640x416 dynamic-range and float16 quantized CRAFT models. The float16 version of this resolution is a slam dunk (rightfully leaving behind the barcode which is not a piece of text). . EAST - 640x416 Dynamic-Range &amp; float16 . The performance of the EAST model under these settings are very equivalent to CRAFT - . . Inference results from the 640x416 dynamic-range and float16 quantized EAST models. With float16 quantization and 640x416 as the resolution, the CRAFT model is a clear winner. Notice that the EAST model is still unable to discard the barcode part which might be an important point to note for some applications. . Time to inspect the results for our final and highest resolution - 1280x800. . CRAFT - 1280x800 Dynamic-Range &amp; float16 . Under dynamic-range quantization, the results look okayish. The model misses out on a number of text blocks but the only ones that it detects appear to be neat. . . Inference results from the 1280x800 dynamic-range and float16 quantized CRAFT models. The results from the float16 variant are tremendous (as you probably have guessed by now). . EAST - 1280x800 Dynamic-Range &amp; float16 . At this resolution, the EAST model seems to be performing well too - . . Inference results from the 1280x800 dynamic-range and float16 quantized EAST models. With float16 quantization as well, the CRAFT model beats EAST in terms of the detection quality. . Model Size . When it comes to deploying models to mobile devices model size becomes a really important factor. You may not want to have a heavy model that would, in turn, make your mobile application bulky. Moreover, Playstore and AppStore also have size restrictions on the applications one can host there. . On the other hand, heavier models tend to be slower. If your application cannot have increased inference latency then you would want to have the model size as low as possible. . The following figure shows the size of the CRAFT and EAST models - . . Model (TFLite variants) sizes of CRAFT and EAST. The dynamic-range quantized versions of both the models are in a well-acceptable range with respect to size. However, the float16 variants may still be a bit heavier for some applications. . Inference Latency . Inference latency is also one of the major factors for mobile-based deployments especially when your applications might require instantaneous predictions. We are going to show a comparison between all the settings we considered in the visual inspection section. . To reiterate we performed the benchmarks for this section on a Redmi K20 Pro using 4 threads. In the following figures, we present inference latency of different variants of the CRAFT and EAST models. . . Inference latency of different variants of the CRAFT model. . Inference latency of different variants of the EAST model. As expected, with increased resolution the inference latency also increases. Inference latency is also quite lower for all the variants of the EAST model compared to CRAFT. Earlier we saw how a quantization affects model performance under a particular resolution. As stated earlier, when using these models inside a mobile application, the “Size vs. Performance” trade-off becomes extremely vital. . Important: The results for the float16 1280x800 CRAFT model could not be obtained on our target device. . Memory Usage . In section, we shed light on the total memory allocated for the models while running the TensorFlow Lite Benchmark tool. Knowing about the memory usage of these models helps us plan application releases accordingly as not all the mobile phones may support extensive memory requirements. So based on this information, you may want to set some device requirements for your application using these models. On the other hand, if you would want your application to be as device-agnostic as possible then you may want to maintain separate models according to their size and memory usage. . In this case, also, we are going to consider all the settings we had considered in the previous sections. The following figures give us a sense of the memory footprint left behind by the models - . . Memory footprint of different variants of the CRAFT model. . Memory footprint of different variants of the EAST model. Detection performance-wise, CRAFT was a winner in many cases but if we factor in for inference latency and memory footprint the situation might need reconsideration. In other words, the best performing (with respect to a certain task, detection in this case) model may not always be the best candidate for deployments. . Important: The results for the float16 1280x800 CRAFT model could not be obtained on our target device. . Conclusion . In this post, we presented a comparative study between two text detection models - CRAFT and EAST. We went beyond their task-specific performance and considered various essential factors that one needs to consider when deploying these models. At this point, you might have felt the need to consider another important factor of these models - FPS information of the models on real-time videos. Please check out this repository to get a handle on how to approach that development. . Contribution . Tulasi worked on the CRAFT model while Sayak worked on the EAST model. For the purpose of this post, Tulasi focused on gathering all the relevant information for doing the comparisons while Sayak focused on the writing part. . Thanks to Khanh LeViet from the TFLite team for reviewing the post. .",
            "url": "https://sayak.dev/optimizing-text-detectors/",
            "relUrl": "/optimizing-text-detectors/",
            "date": " • Nov 27, 2020"
        }
        
    
  
    
        ,"post3": {
            "title": "Optimizing MobileDet for Mobile Deployments",
            "content": "This year researchers from the University of Wisconsin-Madison and Google published their work on MobileDet. MobileDet presents an architectural philosophy for designing object detectors specifically targeted toward running on mobile accelerators like DSP, EdgeTPU, and so on. MobileDet yields significant improvement over architectures MobileNetV2+SSDLite and MobileNetV3+SSDLite on the COCO object detection task with the same accelerated inference time. Long story cut short, if you are planning to use object detection models in mobile applications MobileDets may be an extremely good choice. . One fantastic thing about modern-day research is most of the time, the code and essential artifacts (like the trained models) are available publicly. MobileDet is no exception; the authors released their code and pre-trained models in TensorFlow Object Detection (TFOD) API. The model files come in three different variants - . Optimized for mobile CPU | Optimized for EdgeTPU | Optimized for DSP | . Each of these variants includes the pre-trained checkpoints, a TensorFlow Lite (TFLite) compatible model graph, a TFLite model file, a configuration file, and a graph proto. The models were pre-trained on the COCO dataset. . In this post, I am going to be revisiting the TFLite conversion from the pre-trained model checkpoints along with some of the non-trivial things that come up during the process. It is basically an extension of Khanh LeViet and my findings we shared over this GitHub thread. . The code discussed throughout this post is available here as a Colab Notebook. . Important: If you want to train MobileDet models on your own dataset you may find these notebooks useful. They show you how to prepare the dataset, fine-tune a MobileDet model with the dataset, and optimize the fine-tuned model with TFLite. . Why yet another post on model conversion? . Fair question. After all, there are so many great examples and tutorials that show how to use the post-training quantization APIs in TFLite to perform the model conversion. MobileDet models in the TFOD API repository were trained in TensorFlow (TF) 1. If you ever wanted to use the latest TFLite converter to do the conversion, that may not be immediately approachable. . Besides, there are certain caveats to the EdgeTPU and DSP variants. They come in two precision formats - uint8 and float32. The models in uint8 precision were trained using quantization aware training (QAT) while the float32 models were not. During QAT fake quantization nodes get inserted into a model’s computation graph. So, the models trained using QAT usually require some extra care during the TFLite conversion process as we&#39;ll see in a moment. . If we wanted to convert a single shot detector (SSD) based model to TFLite then we first need to generate a frozen graph first that is compatible with the TFLite operator set (as per these guides - TF1 and TF2). The TFOD API team provides stock scripts (TF1, TF2) for this. Both of these scripts add optimized postprocessing operations to the model graph. Now, these operations are not yet supported in int8 precision. So, if you ever wanted to convert these pre-trained checkpoints using full integer quantization, what would have been your approach? . By now, hopefully, I have been able to convince you that this post is not just about regular model conversion in TFLite. The situations we&#39;ll be going through over the next sections may be helpful for your production TFLite models as well. . The hassle-free conversions . Before we build our way toward the fun stuff, let’s start with the conversions that won’t cost us a night’s sleep. Conversions based on dynamic-range and float16 quantization would come under this category. . Important: The EdgeTPU and DSP variants of MobileDet are meant to run on the respective hardware accelerators. These accelerators need a model to be in full integer precision. So converting the EdgeTPU and DSP variants with dynamic-range and float16 quantization does not have any practical usage. . So, for dynamic-range and float16 quantization based conversions, we will be using the CPU variant only. This variant is available here as ssd_mobiledet_cpu_coco. Once the model bundle is untar’d we get the following files - . ├── model.ckpt-400000.data-00000-of-00001 ├── model.ckpt-400000.index ├── model.ckpt-400000.meta ├── model.tflite ├── pipeline.config ├── tflite_graph.pb └── tflite_graph.pbtxt . model.ckpt-* files are the pre-trained checkpoints on the COCO dataset. If you train a MobileDet object detection model on your own dataset, you will have your own model checkpoint files. The tflite_graph.pb file is a frozen inference graph that is compatible with the TFLite operator set, which was exported from the pre-trained model checkpoints. model.tflite file is a TFLite model that was converted from the tflite_graph.pb frozen graph. . In case if you ever train a MobileDet model on your dataset, here’s how you’d get the TFLite frozen graph file (based on this guide mentioned above) - . $ PIPELINE_CONFIG=&quot;checkpoint_name/pipeline.config&quot; $ CKPT_PREFIX=&quot;checkpoint_name/model.ckpt-400000&quot; $ OUTPUT_DIR=&quot;tflite_graph&quot; $ python models/research/object_detection/export_tflite_ssd_graph.py --pipeline_config_path=$PIPELINE_CONFIG --trained_checkpoint_prefix=$CKPT_PREFIX --output_directory=$OUTPUT_DIR --add_postprocessing_op=true . You can see a fully worked out example in the Colab Notebook mentioned above. If everything goes well, then you should have the frozen graph file exported in OUTPUT_DIR. Let’s now proceed to the TFLite model conversion part. . Here’s how the dynamic-range quantization would look like in TensorFlow 2 - . converter = tf.compat.v1.lite.TFLiteConverter.from_frozen_graph( graph_def_file=model_to_be_quantized, input_arrays=[&#39;normalized_input_image_tensor&#39;], output_arrays=[&#39;TFLite_Detection_PostProcess&#39;, &#39;TFLite_Detection_PostProcess:1&#39;, &#39;TFLite_Detection_PostProcess:2&#39;, &#39;TFLite_Detection_PostProcess:3&#39;], input_shapes={&#39;normalized_input_image_tensor&#39;: [1, 320, 320, 3]} ) converter.optimizations = [tf.lite.Optimize.DEFAULT] tflite_model = converter.convert() . A note about some of the parameters and their values from the above code listing - . model_to_be_quantized corresponds to the frozen graph file. | input_arrays and input_shapes are set accordingly with respect to the frozen graph file. As we can see in the figure below that these values have been set correctly. . . | output_arrays is set according to the instructions provided in this guide. Those operations represent four arrays: detection_boxes, detection_classes, detection_scores, and num_detections, usually a mandate for any object detector out there. | . The rest of the parts in the code listing should be familiar to you if you already know about the typical post-training quantization process in TFLite. For float16 quantization, all the things would remain the same; we just need to add this line before calling convert() - converter.target_spec.supported_types = [tf.float16]. . The dynamic-range quantized model is 4.3 MB in size and float16 one is 8.2 MB. Later, we will see how fast this model would run on actual mobile devices with and without different accelerators. . The trickier TFLite conversions for MobileDet . In this section, we will be dealing with the full integer quantization for the three different variants of MobileDet. Full integer quantization is usually more involved than the other quantization formats supported by TFLite. . Representative dataset . Our first step toward doing full integer quantization is preparing a representative dataset. It is required to calibrate the activation ranges so that the quantized model is able to retain the original model performance as much as possible. For the purpose of this post, I sampled 100 images from the COCO training dataset (train2014 split). In my experience, 100 samples as the representative dataset have always been sufficient. I have hosted these images here in case you are interested to use them. . The following code listing denotes a generator function that produces a preprocessed image to the TFLite converter - . rep_ds = tf.data.Dataset.list_files(&quot;train_samples/*.jpg&quot;) HEIGHT, WIDTH = 320, 320 def representative_dataset_gen(): for image_path in rep_ds: img = tf.io.read_file(image_path) img = tf.io.decode_image(img, channels=3) img = tf.image.convert_image_dtype(img, tf.float32) resized_img = tf.image.resize(img, (HEIGHT, WIDTH)) resized_img = resized_img[tf.newaxis, :] yield [resized_img] . Note that these preprocessing steps should be in sync with the actual preprocessing steps that would apply before running inference with your TFLite model. In case if you are interested to know about more complex representative dataset generators you may find this notebook useful. . Also, note that dynamic-range and float16 quantization of the EdgeTPU and DSP variants don’t have much of practical usage. The next section is going to be solely about full integer quantization of these different variants and the nitty-gritty to take into consideration for the conversion process. . Dealing with fake quantization nodes during conversion . The figure below represents a portion of the uint8 EdgeTPU model computation graph. The nodes highlighted in red are inserted by the QAT mechanism. You would notice the same kind of nodes in the uint8 DSP model computation graph as well. . . Now, these nodes have some important implications that we need to consider during the conversion process - . During QAT the activation ranges are already approximated i.e. QAT resembles post-training quantization during training and adjusts the activation ranges accordingly. So, we don’t need to provide a representative dataset for a full integer quantization based conversion. | These fake nodes are generally in integer precision. So, setting an optimization option (converter.optimizations) might lead to inconsistencies. | In order to convert the uint8 models with full integer quantization, we need to set the input and output data type of the TFLite models to integer precision (typically uint8 or int8). As per this documentation, we also need to specify the quantized_input_stats parameter during the conversion process. This is needed in order for the converted TFLite model to map the quantized input values to real values. More details are available here. | . So, how do we realize all of these in code? . converter = tf.compat.v1.lite.TFLiteConverter.from_frozen_graph( graph_def_file=model_to_be_quantized, input_arrays=[&#39;normalized_input_image_tensor&#39;], output_arrays=[&#39;TFLite_Detection_PostProcess&#39;, &#39;TFLite_Detection_PostProcess:1&#39;, &#39;TFLite_Detection_PostProcess:2&#39;, &#39;TFLite_Detection_PostProcess:3&#39;], input_shapes={&#39;normalized_input_image_tensor&#39;: [1, 320, 320, 3]} ) converter.inference_input_type = tf.uint8 converter.quantized_input_stats = {&quot;normalized_input_image_tensor&quot;: (128, 128)} tflite_model = converter.convert() . If you’re thinking this does not look all that gory compared to the above code listing - it does not have to be! The tooling should help you do these things seamlessly. But catching these details during your project development may not be trivial. Note that we don’t specify converter.inference_output_type. Hold your breath, we will come to this in a moment. . After successful execution, we get two full integer quantized models - EdgeTPU one is 4.2 MB and the DSP one is 7.0 MB. . Integer quantization for CPU variants and float32 precision models . The variants that don’t contain fake quantization nodes (CPU and all the models in float32 precision) have a relatively simpler conversion process. Recollect that the EdgeTPU and DSP variants come in two different precisions - uint8 and float32. For example, here’s how it would be for the float32 precision models - . converter.representative_dataset = representative_dataset_gen converter.inference_input_type = tf.uint8 converter.optimizations = [tf.lite.Optimize.DEFAULT] . Note that we are specifying a representative dataset here because the float32 precision models weren’t trained using QAT. For the CPU variant model, the lines of code would slightly change - . converter.inference_input_type = tf.uint8 converter.quantized_input_stats = {&quot;normalized_input_image_tensor&quot;: (128, 128)} converter.optimizations = [tf.lite.Optimize.DEFAULT] . Honestly, I found this configuration by trial and error. I observed that if I specify a representative dataset then it hurts the predictions of the converted model. Also, I found out that specifying converter.quantized_input_stats helped improve the predictions of the converted model. . We don’t specify converter.inference_output_type in this case as well. Let’s get to it now. . Dealing with non-integer postprocessing ops during conversion . Remember that frozen graph exporter scripts provided by the TFOD API team add optimized postprocessing operations to the graph. These operations are not supported in integer precision yet. So, even if you wanted to specify converter.inference_output_type as tf.uint8 you’ll likely get the following error - . RuntimeError: Unsupported output type UINT8 for output tensor &#39;TFLite_Detection_PostProcess&#39; of type FLOAT32. . This is why we did not set the converter.inference_output_type parameter. . This should resolve all the problems you may run into if you ever wanted to convert the MobileDet models offered by the TFOD API team. In the last two sections, we&#39;ll see these converted models in action and how fast they can perform on respective hardware accelerators. . Show me some results . For the CPU variant model, its float16 quantized TFLite provided decent results - . . On Colab, the inference time is about 92.36 ms for this particular model. I experimented with different threshold values for filtering out the weak predictions and a threshold of 0.3 yielded the best results. These results are pretty consistent across the several different models we talked about. . A major point to note here for the EdgeTPU and DSP variants, their converted counterparts would be much slower on Colab since they were specifically optimized for different hardware accelerators. . You are encouraged to play with the different converted models using the Colab Notebook mentioned above and see these results for yourself. . Model benchmarks . In this section, we’ll address the question - “So, how do I choose one among these many models?” Well, you could manually try them all out and see which performs the best on the runtime of your choice. But a more practical approach to this would be to first benchmark these models on a set of devices using the TFLite Benchmark Tool and then decide accordingly. . The following table provides a comprehensive summary of the important statistics about the runtime of different TFLite MobileDet models. These results were generated using the TFLite Benchmark Tool mentioned above. . . * Device used - Pixel 4 (Inference timings are reported in milliseconds) ** As reported here We can see that with the proper hardware accelerators, the DSP EdgeTPU variants can really shine. For the CPU variant, on a GPU accelerated runtime the float16 quantized TFLite model can bring in additional speed boosts. . A catch here is Pixel devices don’t allow third-party applications to use the Hexagon DSP therefore even if we instruct the Benchmark Tool to make use of that the model would fall back to the CPU for execution. This is why for fair benchmarking results for the DSP variants we should consider running the Benchmark Tool on a device (such as Samsung Galaxy S9+) that has Hexagon DSP and also allows third-party applications to use it. . . * Device used - Samsung Galaxy S9+ (Inference timings are reported in milliseconds) . Note: To train a custom MobileDet-based object detector you can refer to these notebooks. . Conclusion . In this post, we discussed some of the intricate problems one may run into while converting different variants of the MobileDet model in TFLite. One aspect about TFLite that I really like is how it provides the tooling needed to deal with practical problems like this. . I am thankful to Khanh for thoroughly guiding me while writing this post. Thanks to Martin Andrews for suggesting textual edits. .",
            "url": "https://sayak.dev/mobiledet-optimization/",
            "relUrl": "/mobiledet-optimization/",
            "date": " • Sep 29, 2020"
        }
        
    
  
    
        ,"post4": {
            "title": "The Maker Philosophy with ML APIs",
            "content": "In this post, I discuss how I used several Google Cloud Platform (GCP) APIsto turn two ideas into small prototypes. It includes my thought process, the problems I ran into while developing the prototypes, and my approach toward tackling them. All the code discussed in the post is available in this repository. . As a Machine Learning (ML) Practitioner, I advocate for having an understanding of the underlying principles of the models and other stuff that I use. This understanding has many extents. Sometimes, it involves minimally implementing models, and sometimes it may not involve the from-scratch implementation. When it does not involve the implementation part and when the model is readily available, I prefer to put such models directly to use and get a sense of their broader capabilities. . With libraries like TensorFlow, PyTorch, and Scikit-Learn, realizing this usage has never been easier. As all of these libraries are open-source, you could easily get access to the low-level primitives of their model APIs whenever you’d like. It may require you to have a sufficient amount of experience with the library you’d use. But as a Machine Learning Practitioner, one cannot skip this practice. It’s important to have a good grip over a particular Machine Learning library given the domain of choice (structured tabular dataset, images, texts, audios, for example). . On the other hand, APIs that offer ML as a service, allow non-ML folks to incorporate the power of Machine Learning in their applications very easily. This way developers can prototype ideas faster than ever. Some would argue that leaky abstractions can hit sooner than expected and it can be particularly very miserable in Machine Learning. Nonetheless, if you are more on the applied side of things and don’t want to worry about this aspect, that’s perfectly fine. . I wanted to revisit this idea through the lens of an ML Practitioner. More precisely, I wanted to build a series of short demos utilizing the Cloud ML APIs offered by Google Cloud Platform. The premise here is if I have an idea for an ML project, I wanted to see how quickly I can develop a PoC around it. . The ideation phase . Let me quote Emil Wallner from this interview - . It’s important to collect objective evidence that you can apply machine learning. . With regard to successful ML practice, this statement couldn’t have been more appropriate. Machine Learning has affected almost every industry in some way, it has changed the way we develop and perceive software. Coming up with an ML application idea that’s not already there or implemented is actually pretty hard. . So, I ideated the prototypes drawing inspiration from what is already available. For example, Dale and Kaz of Google built this uber-cool demo that lets you transform a PDF into an audiobook. I really wanted to build something similar but in a more minimal capacity -- something that could solely run on a Colab Notebook. I decided to revisit some of the GCP ML APIs that I already knew, Vision, Text-to-Speech APIs, for example. As someone that is already working in the field of Computer Vision, I was inclined to do something that involves it. So here are some initial ideas that came to mind after spending a considerable amount of time with the different API documentation available on GCP: . A pipeline that takes a short video clip, detects the entities present in the video and generates an audio clip dictating detected entity labels. This allowed me to spend some time with GCP’s Video Intelligence API. . | A pipeline that takes an arXiv paper and generates an audio clip of the paper abstract. This was inspired by the demo that Dale and Kaz had already built. . | . Note that if you are already experienced with the Vision and Text-to-Speech APIs then these may seem very trivial. . The mental model . After these ideas, I designed a bunch of visual workflows demonstrating the steps required to realize these ideas along with the right tooling. Here’s an example - . . I also like to refer to these workflows as mental models. Additionally, it helps me to figure out the major dependencies and steps that may be required for the work so that I can plan accordingly. I discuss the importance of developing mental models in this blog post. . (You might have noticed that the above model is a bit different from the first initial idea - I added a logo detection block in there as well.) . Here is another workflow I developed for the second idea I mentioned above: . . This is slightly different from the initial idea I had. In fact, it does not even incorporate anything related to the Vision API. If I only wanted to deal with arXiv papers, I thought using the arXiv API (I used the arXiv Python library) would be a far more reasonable option here since it already provides important information about an arXiv paper such as its categories, abstract, last updated date, and so on. . Finally, I wanted to combine the Vision and Text-to-Speech APIs for the second idea I had. In their demos, Dale and Kaz used AutoML Tables to train a model capable of classifying a paragraph of text into the following categories - “body&quot;, &quot;header&quot;, &quot;caption&quot; and &quot;others&quot;. But I wanted to see if I can bypass this additional training step to filter out the abstract block of a paper and perform optical character recognition (OCR) locally. So, I came up with the following workflow - . . As we can see I am using two Python libraries additionally - . pdf2image - as the name suggests, it is for converting a PDF file to PNG. . | pytesseract - this is for performing OCR locally on an image. . | . In the next sections, I&#39;ll discuss the problems I faced while implementing these workflows in code, and how I went about approaching the solutions. . Building a short video descriptor . In the following texts, we will go over the main ingredients that turned out to be important while developing the prototypes. This will include some code along with the motivation to justify their inclusion. . For the first two workflows, it was mostly about reading the documentation carefully and figuring out the right APIs to use. GCP provides first-class documentation for these APIs with bindings available in many different languages as you can see in the figure below - . . I repurposed these code snippets for the workflows. The Python binding of the Video Intelligence API is simple to use - . You first instantiate the client and instruct what all you are interested in performing - . video_client = videointelligence.VideoIntelligenceServiceClient() features = [videointelligence.enums.Feature.LABEL_DETECTION] . It provides a bag of different features like entity detection, logo recognition, text recognition, object tracking, and so on. Here I am only interested in performing entity detection on a per-segment basis. A user usually specifies segments if they are interested to only analyze a part of their videos. I didn’t specify any segments, and in that case, the Video Intelligence API handles the entire video as a segment. The API also allows you to perform label detection on more granular levels, i.e. on both shot and frame levels. . After the initialization, it was only a matter of a few keystrokes till I made my first video annotation request - . # Specify the mode in which label detection is to be performed mode = videointelligence.enums.LabelDetectionMode.SHOT_AND_FRAME_MODE config = videointelligence.types.LabelDetectionConfig(label_detection_mode=mode) context = videointelligence.types.VideoContext(label_detection_config=config) # Make the request operation = video_client.annotate_video( input_uri=gcs_path, features=features, video_context=context) . Here I am supplying a GCS bucket path of the video I wanted to infer on. Processing the results of the operation is also straightforward - . # Process video/segment level label annotations # Get the first response, since we sent only one video. segment_labels = operation.result.annotation_results[0].segment_label_annotations video_labels = [] for (i, segment_label) in enumerate(segment_labels): print(&quot;Video label description: {}&quot;.format(segment_label.entity.description)) video_labels.append(segment_label.entity.description) . After I got the entity labels on the entire video the next task was to use the Text-to-Speech API to generate an audio clip. For that, I simply followed the official tutorial and reused the code. . The logo detection pipeline is almost similar with some very minor changes. In case you want to catch all the details please follow this Colab Notebook. . I tested the entire workflow on the following video and you can see the outputs right below it - . Processing video for label annotations: Finished processing. Video label description: sidewalk Video label description: street Video label description: public space Video label description: pedestrian Processing video for logo detection: Finished processing. . As for the audio clip, it got came out pretty nice - . Speed-wise the entire pipeline executed pretty quickly. . I had some previous experience working with videos, so I was able to get an idea of what was going under the hood for the video-related activities but for speech, I plan to get to that probably in the next summer (?) . A potential extension of this demo could be developed to aid blind people to navigate their ways when they are outside. I developed this demo keeping this mind, hence you won&#39;t see any visual results. . Detecting, cropping, and reading an arXiv summary . I presented with two different workflows for the second idea i.e. get the abstract of an arXiv paper and generate an audio clip of it. The workflow involving the arxiv Python library wasn’t problematic at all, so I am not going to discuss it in detail. You can always check out this fully worked out Colab Notebook in case you are interested. . The other workflow is a bit more involved. In there, I wanted to take an arXiv paper in PDF format, use the Vision API to get blocks of texts from it, and then locate the abstract from there like so - . . But that’s not it. I also wanted to perform OCR locally on the text blocks. This essentially allowed me to reduce the number of calls to the Vision API and thereby saving me some $. The final piece of the puzzle was to take the local OCR results and generate an audio clip. If you saw the Text-to-Speech documentation, you probably noticed that it is really not a big deal. . So, to realize this workflow here’s what I did (Colab Notebook) - . As I am only interested in dealing with the abstract of a paper, I first converted the entire PDF-formatted paper to PNG and serialized only the first page. I used the pdf2png library for this. | Next, I used the Vision API to make a document_text_detection() request for getting the dense text blocks. The code for this is again, very straightforward - . client = vision.ImageAnnotatorClient() bounds = [] with io.open(image_file, &#39;rb&#39;) as image_file: content = image_file.read() image = types.Image(content=content) response = client.document_text_detection(image=image) document = response.full_text_annotation # Segregate the blocks for page in document.pages: for block in page.blocks: bounds.append(block.bounding_box) . | Then I used the example presented here to draw the bounding boxes on the input image which we saw earlier. I also reused these bounding boxes to segregate different blocks as inferred by the Vision API. . | I am not going to get into the gory details of how I did the segregation. The catch here is for dense text block detection, Vision API returns polygon coordinates and not rectangular coordinates. So, I had to take polygon crops to segregate the different text blocks. (Thanks to this StackOverflow thread.) . | After the segregation part, I used pytesseract to perform OCR on the segregated text blocks. In pytesseract it’s literally doable with text = pytesseract.image_to_string(image_block). | Now, an abstract cannot be just a single character (if the OCR was performed correctly). So I only considered those OCR’d texts where the character length is greater than 1000. | Even with this kind of thresholding, you’d end up with multiple text blocks where this criterion holds. To counter this, I first sorted the OCR’d text blocks with respect to their character lengths and checked if a text block contained only one or no reference to citations. If this criterion was matched then the text block is returned as the abstract. . Here’s how I coded it up: . texts_sorted = sorted(texts, key=len) for text in texts_sorted: if text.split()[0].isupper() &amp; text.count(&quot;[&quot;) &lt;= 1: abstract = text . The upper case criterion is there to ensure an abstract always starts with an uppercase letter. . I am aware that these handcrafted rules can get broken for many instances. But I wanted to explore this possibility anyway. . | To make sure the Text-to-Speech API does not account for any citation I filtered out the raw text to escape them - raw_lines = re.sub(&quot;[[ s* d* ,*]*]&quot;, &quot;&quot;, raw_lines). . | . And that’s it! After a number of trial and error rounds, I was able to get a decent output. . . Final thoughts . Throughout this post, we went over two different ideas that are good prototype candidates for Machine Learning. We saw how easy it is to see these ideas in actions with different ML APIs. We saw how to make these different APIs work together to solve a given problem. Now, if you are feeling excited enough, you can dive deeper into the different ML tasks we saw: detection and classification, for example. Also note that even if one is using these APIs, it’s important to be able to process the API responses properly for the project at hand. . I would like to leave you with this amazing resource provided by GCP. It includes detailed solution walkthroughs of real-world problem scenarios across a wide range of different industry verticals. They also show how to make the best use of different GCP services. . I would like to thank Karl Weinmeister for reviewing this post and for sharing his valuable feedback. Also, thanks to the GDE program for providing the GCP credit support which made these demos possible. .",
            "url": "https://sayak.dev/mlapis-maker/",
            "relUrl": "/mlapis-maker/",
            "date": " • Sep 25, 2020"
        }
        
    
  
    
        ,"post5": {
            "title": "A few favorite recipes in computer vision & deep learning",
            "content": "A few days ago from the time of writing this blog post I tweeted - Some recent favorite recipes (#CV &amp; #DL):👉Have loads of labeled data? Try improving your image classifier with Supervised Contrastive Learning. 👉Don&#39;t have loads but loads of unlabeled data? Try SimCLRv2.👉Just want to fine-tune? Try BigTransfer. 1/3 . &mdash; Sayak Paul (@RisingSayak) July 22, 2020 . In this blog post, I will expand on this tweet to convey why these are my favorite recipes among other things. . The training frameworks I mentioned can be classified into two broad categories - . supervised learning (Supervised Contrastive Learning [1] and BigTransfer [2]) | self-supervised learning (SimCLRv2 [only the SimCLR part]). | . . Note: that SimCLR [3] and SimCLRv2 [4] are two separate works. . So, why self-supervised learning anyway? . The field of self-supervised visual representation learning is progressing pretty fast. With recent advancements, the deep learning community has started to consider it as an alternative to the fully supervised models for tasks like image classification, object detection, image segmentation, etc. If you are unfamiliar with self-supervised learning check out this blog post by Jeremy Howard. So, why all the fuss around self-supervised visual representation learning? . This is because a self-supervised learning framework can benefit from unlabeled data. Essentially, you would frame a supervised learning task from a large unlabeled corpus and then train a model to learn that task. You see we are not using any explicit label information here. Instead, we are using the given data to form a supervised learning task, this is why it is self-supervised. You would then take the representations from the model (preferably from the encoder part of the model) and use them for downstream tasks. Representations learned using self-supervised learning frameworks like SimCLRv2, SwAV [5] transfer quite well to downstream (vision) tasks even with very less labeled data. . Colin Raffel beautifully summed up the recent progress in the field of self-supervised learning for computer vision - I just made this figure for a class I am teaching on &quot;learning from limited labeled data&quot;. The left plot represents 6 years of results; the right plot is ~1 year. Anyone else feel like our field is moving kinda fast? pic.twitter.com/Kneb96JU12 . &mdash; Colin Raffel (@colinraffel) July 31, 2020 . BYOL [6] and SwAV have even beaten SimCLR - . . One could argue that this is in comparison with SimCLR but not SimCLRv2. Well, that is because SimCLRv2 is not just about self-supervised learning, it is more than that - . . This blog post, however, would only focus on the SimCLR part i.e. the left-most part of the figure above. If you are interested to know more about SimCLRv2, feel free to watch this video by Yannic Kilcher. . Why SimCLR(v2)? . Among all of the techniques that have been mentioned in the post so far, SimCLR is by far the most favorite of mine. This is because of its simplicity and the promise to shine more as one would scale up the base architecture and introduce more (unlabeled data). Moreover, framework wise SimCLR is very consistent with the recipes I would want to see in an effective visual representation learning framework. One of these primary recipes is to maximize the agreement between the semantically similar images. SwAV is also capable of doing this, in fact, it is currently the state-of-the-art (as of August 2020) in this domain. But simplicity wise SimCLR beats SwAV big time. . At a very high-level, SimCLR takes two different views of the same image and tries to maximize the agreement between these two views while minimizing the agreement between the views coming from other images. These different views are obtained by applying augmentation operations like random-resized crops, horizontal flips, color distortions, etc. Representations learned using this framework (and any self-supervised visual representation learning framework in general) can be used in different flavors - . You may have loads of unlabeled data and limited labeled data for your problem. You could use the unlabeled data and incorporate SimCLR for obtaining effective representations and use them to a downstream task where the limited labeled data might be required. | Representations obtained from datasets like ImageNet using SimCLR can be used in regular transfer learning settings. | . . As we can see in SimCLR, the loss function (normalized temperature-scaled cross-entropy loss) operates directly on the features computed by the projection head (MLP part). This makes SimCLR a compute-intensive framework. . On the other hand, SwAV operates by assigning the encoded representations of different views of the same image to clusters. The clusters are being assigned by keeping a differentiable codebook for the prototypes of the different types of images present in the given dataset. Training wise, SwAV tries to maximize the agreement between the clusters of semantically similar images. Operating on the clusters rather than the encoded representations is a lesser compute-intensive task. . . SwAV might appear as a simpler framework than SimCLR but there are a number of different pieces to look after here: . Maintaining a differentiable prototype bank | Optimal transportation of the representations to form soft codes using the Sinkhorn-Knopp algorithm | Multi-crop data augmentation policy | Swapped prediction problem | . When working in practical scenarios we often need to maintain a trade-off between technical feasibility and performance. To me, SimCLR cuts it through in terms of technical feasibility. . Update: Along with Ayush and generous amount of help from Mathilde Caron (first author of SwAV) we were finally able to minimally implement SwAV after realizing the improvements it brings to the table. . Returning to supervised learning . Given the almightly prowess of the self-supervised learning frameworks why even bother about supervised regimes? . Labels + contrastive loss = win-win . Supervised Contrastive Learning addresses a very important point about the self-supervised learning frameworks like SimCLR. In SimCLR, the positive pairs are generated by taking different views of the same image and the negative pairs are then randomly sampled from the other images present in a batch. . . Here are some examples of negative pairs - . . As discussed in the Supervised Contrastive Learning paper, this method of contrasting two different views of the same image can result in false negatives i.e. the samples belonging to the same class might get mapped differently in the embedding space. There&#39;s no way for us to properly mitigate this issue without having access to the original labels. Hence, I mentioned if you have loads of labeled images, it&#39;s better to use Supervised Contrastive Learning to capture meaningful representations. . . Supervised Contrastive Learning extends how we train supervised models by introducing a two stage training framework. In the first stage, it uses the label information in the contrastive loss to learn to map the encoded representations effectively. In the second stage, it train a linear model on top of these encoded representations for the given supervised training objective. . In practice this works quite well - . . You might be feeling very tempted to try out this on your labeled dataset. Truth be told - Supervised Contrastive Learning is also compute-intensive even for relatively small datasets. So, if you don&#39;t have the training budget you might need to reconsider this option. . Maybe you have a relatively smaller labeled dataset and you just want to be able to fine-tune a good enough architecture which is still very useful for many practical scenarios. This is where BigTransfer can really shine. . Returning to supervised transfer learning . BigTransfer is from the family of classic supervised pre-training and transfer the learned representations to downstream tasks. ImageNet has been the choice for this kind of pre-training for a long time. But in BigTransfer, the authors use larger datasets such as ImageNet-21k, JFT along with ImageNet. In order to facilitate these larger datasets they scale up the model architectures along with longer pre-training. Their result speaks for itself - . . To eliminate the dependence on batch statistics the authors make use of Group Normalization and Weight Standardization. Personally, I really liked this recipe because using overall large batch sizes to train larger models at scale is a common choice and using Batch Normalization there could have easily affected the performance of the models during the downstream tasks. . For fine-tuning, the authors propose a heuristics-based BiT-HyperRule which provides instructions on what augmentation policy to use, how many steps to train for, what learning rate schedule to use, etc. . . I found this strategy to be simple enough to be implemented and practised. . Resources . If you are interested to apply these techniques in your own works you may find the following resources to be helpful - . A Colab Notebook by the authors of SimCLRv2 that shows how to fine-tune with SimCLRv2. | A report by Sweta Shaw and myself that walks through Supervised Contrastive Learning along with Colab Notebooks. | A tutorial on BigTransfer by the authors of BigTransfer. | . Here is a list of some other interesting works on transfer learning for computer vision - Here&#39;s a list of my favorite recent papers on transfer learning for vision:- BigTransfer: https://t.co/saYoJM3A8e- VirTex: https://t.co/R59KohXwec- SimCLRv2: https://t.co/6Hcws2v5dx- Self-training: https://t.co/ufLvXD4kqlWould love to see a T5-like paper for vision. . &mdash; Sayak Paul (@RisingSayak) July 20, 2020 . Acknowledgments . Amit&#39;s visual guide on SimCLR and Thalles&#39;s exploratory analysis on SimCLR helped me in developing a thorough understanding of SimCLR. . Thanks to Yannic Kilcher for his explanation videos on SimCLRv2 and Supervised Contrastive Learning. Those made the learning process smoother. . Thanks to Ting Chen (SimCLR author) for providing me with additional pointers on self-supervised learning in general. . Thanks to Jeremy Howard for his fast.ai lectures that continue to help me in approaching deep learning recipes with more common sense and practicality. . References . Khosla, Prannay, et al. “Supervised Contrastive Learning.” ArXiv:2004.11362 [Cs, Stat], Apr. 2020. arXiv.org, http://arxiv.org/abs/2004.11362. | Kolesnikov, Alexander, et al. “Big Transfer (BiT): General Visual Representation Learning.” ArXiv:1912.11370 [Cs], May 2020. arXiv.org, http://arxiv.org/abs/1912.11370. | Chen, Ting, Simon Kornblith, Mohammad Norouzi, et al. “A Simple Framework for Contrastive Learning of Visual Representations.” ArXiv:2002.05709 [Cs, Stat], June 2020. arXiv.org, http://arxiv.org/abs/2002.05709. | Chen, Ting, Simon Kornblith, Kevin Swersky, et al. “Big Self-Supervised Models Are Strong Semi-Supervised Learners.” ArXiv:2006.10029 [Cs, Stat], June 2020. arXiv.org, http://arxiv.org/abs/2006.10029. | Caron, Mathilde, et al. “Unsupervised Learning of Visual Features by Contrasting Cluster Assignments.” ArXiv:2006.09882 [Cs], July 2020. arXiv.org, http://arxiv.org/abs/2006.09882. | Grill, Jean-Bastien, et al. “Bootstrap Your Own Latent: A New Approach to Self-Supervised Learning.” ArXiv:2006.07733 [Cs, Stat], June 2020. arXiv.org, http://arxiv.org/abs/2006.07733. | “Advancing Self-Supervised and Semi-Supervised Learning with SimCLR.” Google AI Blog, http://ai.googleblog.com/2020/04/advancing-self-supervised-and-semi.html. | Facebookresearch/Swav. 2020. Facebook Research, 2020. GitHub, https://github.com/facebookresearch/swav. | Exploring SimCLR: A Simple Framework for Contrastive Learning of Visual Representations - Thalles’ Blog. https://sthalles.github.io/simple-self-supervised-learning/. | BigTransfer (BiT): State-of-the-Art Transfer Learning for Computer Vision. https://blog.tensorflow.org/2020/05/bigtransfer-bit-state-of-art-transfer-learning-computer-vision.html. |",
            "url": "https://sayak.dev/visual-representation-learning/self-supervised-learning/computer-vision/2020/08/02/favorite-recipes-vision.html",
            "relUrl": "/visual-representation-learning/self-supervised-learning/computer-vision/2020/08/02/favorite-recipes-vision.html",
            "date": " • Aug 2, 2020"
        }
        
    
  
    
        ,"post6": {
            "title": "Using TensorRT for accelerated deep learning inference",
            "content": "If you see the way deep learning research has progressed over the years, it has always been guided by the need of the hour. If I were to develop a chronology out of it, it would be something like - train better model -&gt; train them faster -&gt; get them good at generalizing well, and so on. With a stern increase in the demand for using deep learning more as just another technology stack, there could not have been a better time to think about how do we make our models infer faster. In this post, we are going to see how to use TensorRT to perform accelerated inference with TensorFlow (2) models. After all, making predictions with deep learning models is what makes you real 💰 and we would want to make sure that our bucks burned judiciously. . Performing inference with a pre-trained image classification model . Let’s first do the groundwork. We will be using a pre-trained (on ImageNet) MobileNetV2 model throughout the post. For this section, we will be using tf.keras to load this model and we will then use it to perform inference. We will time the performance of this model. . The code to download the weights of the pre-trained MobileNetV2 model is straightforward - . mobilenet_v2 = tf.keras.applications.MobileNetV2(weights=&#39;imagenet&#39;) mobilenet_v2.save(&#39;mobilenet_v2&#39;) . Downloading data from https://storage.googleapis.com/tensorflow/keras-applications/mobilenet_v2/mobilenet_v2_weights_tf_dim_ordering_tf_kernels_1.0_224.h5 14540800/14536120 [==============================] - 0s 0us/step WARNING:tensorflow:From /usr/local/lib/python3.6/dist-packages/tensorflow/python/ops/resource_variable_ops.py:1817: calling BaseResourceVariable.__init__ (from tensorflow.python.ops.resource_variable_ops) with constraint is deprecated and will be removed in a future version. Instructions for updating: If using Keras pass *_constraint arguments to layers. INFO:tensorflow:Assets written to: mobilenet_v2/assets . Here, mobilenet_v2 is a directory and when you pass a directory to the save function, it serializes the model in the TensorFlow SavedModel format. This format makes it easier for us to be able to use it on different platforms - be it on GCP’s AI Platform, be it on TensorFlow JS, be it on TensorFlow Serving, and so on. . Now, there are some basic preprocessing steps to be followed before we can actually feed an image to this model - . # Prepare the image for prediction img = tf.keras.preprocessing.image.load_img(&#39;elephant.jpg&#39;, target_size=(224, 224)) x = tf.keras.preprocessing.image.img_to_array(img) x = np.expand_dims(x, axis=0) x = tf.keras.applications.mobilenet_v2.preprocess_input(x) . Here’s how elephant.jpg looks like in case if anyone’s curious - . Now, running the prediction and decoding it is just a matter of two lines of code - . # Run inference preds = mobilenet_v2.predict(x) print(&#39;Predicted:&#39;, tf.keras.applications.mobilenet_v2.decode_predictions(preds, top=3)[0]) . Downloading data from https://storage.googleapis.com/download.tensorflow.org/data/imagenet_class_index.json 40960/35363 [==================================] - 0s 0us/step Predicted: [(&#39;n02504013&#39;, &#39;Indian_elephant&#39;, 0.70024925), (&#39;n01871265&#39;, &#39;tusker&#39;, 0.2549572), (&#39;n02504458&#39;, &#39;African_elephant&#39;, 0.0033761878)] . To find out how much time does this model take to predict a given image? Let’s write a short utility function to handle that - . def time_my_model(model, data): times = [] for i in range(20): start_time = time.time() one_prediction = model.predict(data) delta = (time.time() - start_time) times.append(delta) mean_delta = np.array(times).mean() fps = 1 / mean_delta print(&#39;average(sec):{:.2f},fps:{:.2f}&#39;.format(mean_delta, fps)) . If we run time_my_model fives times the output would look like so - . average(sec):0.06,fps:15.48 average(sec):0.03,fps:32.26 average(sec):0.03,fps:32.48 average(sec):0.03,fps:31.14 average(sec):0.03,fps:31.67 . Can we further optimize this? We will start the next section with this question. . Optimizing the pre-trained image classification model . Note that explaining the different means of optimizing a deep learning model is out of the scop for this post. If you are interested, the following posts are great starting points - . High performance inference with TensorRT Integration . | Optimizing TensorFlow Models for Serving . | . Let’s now introduce the big elephant in the room - TensorRT. TensorRT is an SDK by NVIDIA for performing accelerated deep learning inference. It utilizes Tensor Cores of an NVIDIA GPU (for example V100, P4, etc.) and performs a number of model optimization steps for including parameter quantization, constant folding, model pruning, layer fusion, etc. You can know more about this SDK from here. . Note that TensorRT will only be able to achieve acceleration when it’s used on supported hardware. For more on this, check out the aforementioned link. . Optimizing the MobileNetV2 model is a three-step process - . Setting up the optimization configuration - . params = trt.DEFAULT_TRT_CONVERSION_PARAMS._replace( precision_mode=&#39;FP16&#39;, is_dynamic_op=True) . We use the precision_mode argument to specify the numerical precision of the model parameters we would want. In this case it is FP16 (float16). is_dynamic_op argument is set to True so that the shapes would be determined during runtime. Onto the next step. . (trt is aliased as from tensorflow.python.compiler.tensorrt import trt_convert as trt.) . | Performing the model conversion for optimization - . As the headline suggests, in this step we actually perform the conversion with the configurations we specified in the previous step to optimize our model. . converter = trt.TrtGraphConverterV2( input_saved_model_dir=&#39;mobilenet_v2&#39;, conversion_params=params) converter.convert() . For the conversion to take place, we are supplying the pre-trained MobileNetV2 model in the SavedModel format. It’s really nice to see how this format comes to unify different platforms. . | Serializing the optimized model - . Serializing this optimized model is similar to how we did it for the pre-trained model - . saved_model_dir_trt = &#39;mobilenet_v2.trt&#39; converter.save(saved_model_dir_trt) . | . Now, how good is this new variant of the model? How accurate will it be? How much faster will it be? We will find those out in a moment. Before that let’s see how to run inference with this optimized model in the next section. . Running inference with the optimized model . TensorFlow 2.x provides a convenient function tf.saved_model.load to load the models saved in SavedModel. We are only interested in performing inference with the model so we will load the respective signature from the model as a concrete function - . # Load the particular signature from the TRT graph root = tf.saved_model.load(saved_model_dir_trt) concrete_func = root.signatures[&#39;serving_default&#39;] . You can inspect the structure of this function by running concrete_func.structured_outputs and the output would be - . {&#39;predictions&#39;: TensorSpec(shape=(None, 1000), dtype=tf.float32, name=&#39;predictions&#39;)} . As we would expect, this function will yield a 1000-d vector which is nothing but probabilities distributed across the 1000 different classes of the ImageNet dataset. Also note the key of the above dictionary, it might not be ‘Logits’ always. . Now, to be able to run the inference and decode them in a human-interpretable way, we first need to get the ImageNet dataset labels - . #hide_output # Gather the ImageNet labels first and prepare them labels_path = tf.keras.utils.get_file(&#39;ImageNetLabels.txt&#39;, &#39;https://storage.googleapis.com/download.tensorflow.org/data/ImageNetLabels.txt&#39;) imagenet_labels = np.array(open(labels_path).read().splitlines()) . Time for performing the inference - . # Perform inference labeling = concrete_func(tf.constant(x.astype(&#39;float32&#39;))) activations = tf.nn.softmax(labeling[&#39;predictions&#39;]) imagenet_labels[np.argsort(activations)[0,::-1][:5]+1] . array([&#39;Indian elephant&#39;, &#39;tusker&#39;, &#39;African elephant&#39;, &#39;bull mastiff&#39;, &#39;Great Dane&#39;], dtype=&#39;&lt;U30&#39;) . Looks like our optimized model got it right! . While parsing the predictions, we would need to put focus on the key in this case which is &#39;predictions&#39;. . Battle of performance . Let’s first recall where we were with our pre-trained MobileNetV2 - . average(sec):0.03,fps:37.22 average(sec):0.03,fps:36.54 average(sec):0.03,fps:36.54 average(sec):0.03,fps:38.93 average(sec):0.03,fps:37.24 . Now, to time the performance of our optimized model, we will need to make little adjustments to the utility function we previously wrote. This is mainly because now, we will now be using a concrete function which takes a tf.constant. . def time_trt_model(): image_input = tf.constant(x.astype(&#39;float32&#39;)) times = [] for i in range(20): start_time = time.time() one_prediction = concrete_func(input_1=image_input) delta = (time.time() - start_time) times.append(delta) mean_delta = np.array(times).mean() fps = 1 / mean_delta print(&#39;average(sec):{:.2f},fps:{:.2f}&#39;.format(mean_delta, fps)) . For convenience, here’s our x - . img = tf.keras.preprocessing.image.load_img(&#39;elephant.jpg&#39;, target_size=(224, 224)) x = tf.keras.preprocessing.image.img_to_array(img) x = np.expand_dims(x, axis=0) x = tf.keras.applications.mobilenet_v2.preprocess_input(x) . Let’s now run time_trt_model() for five times - . average(sec):0.00,fps:227.01 average(sec):0.00,fps:279.10 average(sec):0.00,fps:269.89 average(sec):0.00,fps:277.14 average(sec):0.00,fps:219.98 . That’s quite a bit of improvement, isn’t it? Note that you may observe slower inference in your first call to time_trt_model(). It may happen because of the additional time a GPU takes to set itself up. When running comparisons like this, it’s a good practice to first warm up the base hardware by running a few test iterations on it and then run the actual iterations for comparison. Depending on the GPU you&#39;re using, these numbers can vary (these experiments were performed a Tesla P100). . Talking about the memory footprints of both the models, for the pre-trained model we have - . # Size of the model files !du --all -h mobilenet_v2 . 96K mobilenet_v2/variables/variables.data-00000-of-00002 14M mobilenet_v2/variables/variables.data-00001-of-00002 20K mobilenet_v2/variables/variables.index 14M mobilenet_v2/variables 3.9M mobilenet_v2/saved_model.pb 4.0K mobilenet_v2/assets 18M mobilenet_v2 . We have a total of 18 MB here. For the optimized model, we have - . !du --all -h mobilenet_v2.trt . 96K mobilenet_v2.trt/variables/variables.data-00000-of-00002 14M mobilenet_v2.trt/variables/variables.data-00001-of-00002 20K mobilenet_v2.trt/variables/variables.index 14M mobilenet_v2.trt/variables 31M mobilenet_v2.trt/saved_model.pb 4.0K mobilenet_v2.trt/assets 45M mobilenet_v2.trt . Woah! The size has increased in this case! This is because the computational graph of our optimized model has been changed. However, the size of the parameters (mobilenet_v2/variables and mobilenet_v2.trt/variables) of both models is the same. . In real-life situations, as a machine learning practitioner, you will often have to make trade-offs between memory footprints, performance both in terms of accuracy and inference time. So having the knowledge of employing the right tools at the right moment will help you a long way. So, if you are looking for reducing the memory footprint of the model as well as accelerating the inference time, TensorFlow Lite is a good choice. In the bonus section of the post, we are going to discuss it. . Important: TensorFlow has now introduced a tf.experimental.tensorrt.Converter API with better support for TensorRT. . Using TensorRT on your custom models . This section is for you to pick up. It will be a nice weekend project to train a simple model on a custom dataset and compare the performances as we saw in this post. Additionally, it will be interesting to compare different evaluation metrics like accuracy, precision, and recall for the different models (a custom trained mode, its optimized variants). We barely scratched the surface of TensorRT in this post. You are encouraged to experiment with the different arguments that come with the functions we saw in the post and figure out what works the best for your use-case. If your use-case involves embedded devices and mobile phones then TensorFlow Lite will be another great framework for you to explore. .",
            "url": "https://sayak.dev/tf.keras/tensorrt/tensorflow/2020/07/01/accelerated-inference-trt.html",
            "relUrl": "/tf.keras/tensorrt/tensorflow/2020/07/01/accelerated-inference-trt.html",
            "date": " • Jul 1, 2020"
        }
        
    
  
    
        ,"post7": {
            "title": "Different data augmentation recipes in `tf.keras` for image classification",
            "content": "Data augmentation is a favorite recipe among deep learning practitioners especially for the ones working in the field of computer vision. Data augmentation is a technique used for introducing variety in training data thereby helping to mitigate overfitting. . When using Keras for training image classification models, using the ImageDataGenerator class for handling data augmentation is pretty much a standard choice. However, with TensorFlow, we get a number of different ways we can apply data augmentation to image datasets. In this tutorial, we are going to discuss three such ways. Knowing about these different ways of plugging in data augmentation in your image classification training pipelines will help you decide the best way for a given scenario. . Here’s a brief overview of the different ways we are going to cover: . Using the standard ImageDataGenerator class | Using TensorFlow image ops with a TensorFlow dataset | Using Keras’s (experimental) image processing layers | Mix-matching different image ops &amp; image processing layers | . Let’s get started! . Experimental setup . We are going to use the flowers dataset to demonstrate the experiments. Downloading the dataset is just as easy as executing the following line of code: . flowers contains the path (which in my case is - /root/.keras/datasets/flower_photos) where the dataset got downloaded. The structure of the dataset looks like so - . ├── daisy [633 entries] ├── dandelion [898] ├── roses [641] ├── sunflowers [699 entries] ├── tulips [799 entries] └── LICENSE.txt . # Get the flowers dataset flowers = tf.keras.utils.get_file( &#39;flower_photos&#39;, &#39;https://storage.googleapis.com/download.tensorflow.org/example_images/flower_photos.tgz&#39;, untar=True) . Using the standard ImageDataGenerator class For most of the scenarios, the ImageDataGenerator should be good enough. Its flexible API design is really to follow and it makes it easier to work with custom image datasets by providing meaningful high-level abstractions. . We instantiate the ImageDataGenerator class like so - . img_gen = tf.keras.preprocessing.image.ImageDataGenerator( rescale=1./255, rotation_range=30, horizontal_flip=True) . We specify two augmentation operations and a pixel rescaling operation in there. ImageDataGenerator comes with a handy flow_from_directory method that allows us to read images from a directory and apply the specified operations on the fly during the time of training. Here’s how to instruct the img_gen object to read images from a directory - . IMG_SHAPE = 224 BATCH_SIZE = 32 img_flow = img_gen.flow_from_directory(flowers, shuffle=True, batch_size=BATCH_SIZE, target_size=(IMG_SHAPE, IMG_SHAPE)) . Found 3670 images belonging to 5 classes. . We then verify the images and the labels and they are indeed parsed right - . images, labels = next(img_flow) print(images.shape, labels.shape) show_batch(images, labels) . (32, 224, 224, 3) (32, 5) . Training with an ImageDataGenerator instance is extremely straight-forward - . model = get_training_model() model.fit(img_flow, ...) . For a fully worked out example, refer to this tutorial. . As can be seen in this blog post, ImageDataGenerator’s overall data loading performance can have a significant effect on how fast your model trains. To tackle situations, where you need to maximize the hardware utilization without burning unnecessary bucks, TensorFlow’s data module can be really helpful (comes at some costs). . TensorFlow image ops with tf.data APIs . The blog post I mentioned in the previous section shows the kind of performance boost achievable with tf.data APIs. But it’s important to note that boost comes at the cost of writing boilerplate code which makes the overall process more involved. For example, here’s how you would load and preprocess your images and labels - . def parse_images(image_path): # Load and preprocess the image img = tf.io.read_file(image_path) # read the raw image img = tf.image.decode_jpeg(img, channels=3) # decode the image back to proper format img = tf.image.convert_image_dtype(img, tf.float32) # scale the pixel values to [0, 1] img = tf.image.resize(img, [IMG_SHAPE, IMG_SHAPE]) # resize the image # Parse the labels label = tf.strings.split(image_path, os.path.sep)[5] return (img, label) . You would then write a separate augmentation policy with the TensorFlow Image ops - . def augment(image, label): img = tf.image.rot90(image) img = tf.image.flip_left_right(img) return (img, label) . To chain the above two together you would first create an initial dataset consisting of only the image paths - . image_paths = list(paths.list_images(flowers)) list_ds = tf.data.Dataset.from_tensor_slices((image_paths)) . Now, you would read, preprocess, shuffle, augment, and batch your dataset - . AUTO = tf.data.experimental.AUTOTUNE train_ds = ( list_ds .map(parse_images, num_parallel_calls=AUTO) .shuffle(1024) .map(augment, num_parallel_calls=AUTO) # augmentation call .batch(BATCH_SIZE) .prefetch(AUTO) ) . num_parallel_calls allows you to parallelize the mapping function and tf.data.experimental.AUTOTUNE lets TensorFlow decide the level of parallelism to use dynamically (how cool is that?). prefetch allows loading in the next batch of data well before your model finishes the current epoch of training. It is evident that this process is more involved than the previous one. . Verifying if we constructed the data input pipeline correctly is a vital step before you feed your data to the model - . image_batch, label_batch = next(iter(train_ds)) print(image_batch.shape, label_batch.shape) show_batch(image_batch.numpy(), label_batch.numpy(), image_data_gen=False) . (32, 224, 224, 3) (32,) . The “b”s appear before the class labels because TensorFlow parses the strings as byte-strings. Using train_ds with your model is also just about executing - . model = get_training_model() model.fit(train_ds, ...) . Here you can find a fully worked out example. Here you can know more about the different performance considerations when using tf.data. There are more image ops available with TensorFlow Addons which can found here. . Recently, Keras introduced image_dataset_from_directory function (only available in tf-nightly at the time of writing this) which takes care of many of the boilerplate code we saw above and still yields pretty good performance. Here’s a tutorial that shows how to use it. . Keras has also introduced a number of image processing layers which can be very useful to build flexible augmentation pipelines using the Sequential API. In the next section, let’s see how. . Using Keras&#8217;s (experimental) image processing layers . Just like you would construct an entire model using the Sequential API, you can now construct very flexible data augmentation pipelines using the newly introduced (although experimental at the time of writing this) image processing layers. If we were to convert the data augmentation operations we have been following in the tutorial so far, building a data augmentation pipeline using this approach would be like so - . data_augmentation = tf.keras.Sequential([ tf.keras.layers.experimental.preprocessing.RandomFlip(&#39;horizontal&#39;), tf.keras.layers.experimental.preprocessing.RandomRotation(0.3) ]) . Before passing your data through this stack of layers makes sure you haven’t applied any augmentation already. So, it’s safe to create a separate TensorFlow dataset without mapping the augmentation function like we previously did - . # Create TensorFlow dataset without any augmentation train_ds = ( list_ds .map(parse_images, num_parallel_calls=AUTO) .shuffle(1024) .batch(BATCH_SIZE) .prefetch(AUTO) ) . Now, we can see how to examine some of the augmented images that would come out of this mini pipeline - . image_batch, label_batch = next(iter(train_ds)) plt.figure(figsize=(10, 10)) for n in range(25): ax = plt.subplot(5, 5, n+1) augmented_image = data_augmentation(tf.expand_dims(image_batch[n], 0)) plt.imshow(augmented_image[0].numpy()) plt.title(label_batch[n].numpy().decode(&quot;utf-8&quot;)) plt.axis(&#39;off&#39;) . We can also make use of Python lambdas to map data_augmentation directly to our tf.data pipeline like so: . train_ds = ( list_ds .map(parse_images, num_parallel_calls=AUTO) .shuffle(1024) .batch(BATCH_SIZE) .map(lambda x, y: (data_augmentation(x), y), num_parallel_calls=AUTO) .prefetch(AUTO) ) . Note that these layers can be also added as a part of your model allowing them to run on GPUs. Based on your compute budget you should decide if you would want to run these layers on the GPU or you would rather have them executed separately on the CPU. . A functional model definition in Keras using this approach may look like so - . # You define an input layer with pre-defined shapes inputs = keras.Input(shape=(IMG_SHAPE, IMG_SHAPE, 3)) x = data_augmentation(inputs) # Apply random data augmentation x = feature_extractor_model(x, training=False) x = GlobalAveragePooling2D()(x) x = Dropout(0.2)(x) outputs = Dense(1)(x) model = Model(inputs, outputs) . Now, model should be good to go with - model.fit(train_ds, ...). A fully worked out example is available here. Note that, performance might get slightly affected when going with this approach since the GPUs will be utilized to run the preprocessing layers as well. . Let’s now think about situations where we may need to use a combination of the image ops of TensorFlow and the layers we just saw. What if we need to plug in custom augmentation operations in the augmentation pipeline? Added on top of it, what if we need to fix the probability at which the augmentation operations would get applied? Data augmentation pipelines are quite central behind the success of recent works like SimCLR, Augmix, etc. . Note: These layers have pre-defined inference-time behaviour. So even if you have included them inside your model itself, it&#8217;s totally fine. But if you want them during inference, you would need to set its inference-time behaviour. . Towards more complex augmentation pipelines . In this final approach, we will see how to mix and match between the different stock image ops, and stock image processing layers. Let’s first define a class utilizing the stock image ops with a utility function to apply them at random with a pre-defined probability. . class CustomAugment(object): def __call__(self, image): # Random flips and grayscale with some stochasticity img = self._random_apply(tf.image.flip_left_right, image, p=0.6) img = self._random_apply(self._color_drop, img, p=0.9) return img def _color_drop(self, x): image = tf.image.rgb_to_grayscale(x) image = tf.tile(x, [1, 1, 1, 3]) return x def _random_apply(self, func, x, p): return tf.cond( tf.less(tf.random.uniform([], minval=0, maxval=1, dtype=tf.float32), tf.cast(p, tf.float32)), lambda: func(x), lambda: x) . _random_apply is taken from the official SimCLR repository. Now, in order to tie it together with the stock image processing layers, we can still use the Sequential API with a Lambda layer - . # Build the augmentation pipeline data_augmentation = tf.keras.Sequential([ tf.keras.layers.Lambda(CustomAugment()), tf.keras.layers.experimental.preprocessing.RandomRotation(0.1) ]) . When we verify if it’s indeed correct, we get desired outputs - . image_batch, label_batch = next(iter(train_ds)) plt.figure(figsize=(10, 10)) for n in range(25): ax = plt.subplot(5, 5, n+1) augmented_image = data_augmentation(tf.expand_dims(image_batch[n], 0)) plt.imshow(augmented_image[0].numpy()) plt.title(label_batch[n].numpy().decode(&quot;utf-8&quot;)) plt.axis(&#39;off&#39;) . Training models when using this approach remains the same as the previous one. Keep in mind that performance can get affected when using this approach. . References . Fine-tuning with Keras and Deep Learning | Transfer learning &amp; fine-tuning | Image classification from scratch | Data augmentation | .",
            "url": "https://sayak.dev/tf.keras/data_augmentation/image/2020/05/10/augmemtation-recipes.html",
            "relUrl": "/tf.keras/data_augmentation/image/2020/05/10/augmemtation-recipes.html",
            "date": " • May 10, 2020"
        }
        
    
  
    
        ,"post8": {
            "title": "Sharing your work online effectively",
            "content": "Well, you have put a lot of blood and sweat into writing your latest blog post on Machine Learning. Don&#39;t let your struggle go in vain and let the world know about it. Sharing your blog posts across different channels not only gives you exposure but also may get you tremendous feedback on your work. In my personal experience, the feedback has been super useful for me to improve myself not only as a writer but also as a communicator. There can be times you might have missed out on a super important detail, or you might have unknowingly introduced a snazzy bug in the code listings of your blog -- those things could have been caught in the process of feedback interchange. . In this short article, I am going to enlist a few different ways to share your work and get feedback. Note your work can be anything starting from a crucial GitHub PR, to a weekend project. Although the following platforms and communities are mostly limited to Machine Learning, I hope this guide will be useful for tech bloggers in general. . Sharing on platforms/communities . Before I start the sharing process, I generally create a Google Doc to effectively keep track of where I am sharing my work. This essentially acts as a checklist for all the places I want to share my work on. Here&#39;s the template I follow for creating the Google Doc - . Link to where the work has been posted. | Brief description of the work. | Post table: . . | . I generally keep the description to a maximum of 280 characters so that I can use it on Twitter as well. . Now, turning to the platforms and communities, here are some recommendations (in no particular order): . HackerNews (https://news.ycombinator.com/newest) | Made With ML (https://madewithml.com/) | Reddit r/MachineLearning | r/MachinesLearn | r/learnmachinelearning | r/deeplearning | . | Twitter | Facebook AIDL | Montreal AI | Deep Learning | . | Fast.ai Forum (https://forums.fast.ai/) | LinkedIn | Google Groups (depends on the framework used in the work) discuss@tensorflow.org | tflite@tensorflow.org | tfjs@tensorflow.org | tfx@tensorflow.org | . | . While sharing my work, I find it to be important to always attach a brief description. Additionally, if your work is related to implementing research work, you should definitely include it on Papers with Code. . Sharing to aid discussions . You might be active on online forums like Quora, StackOverflow, and so on. While participating in a discussion in those forums you can make effective use of your work if it is relevant. In these cases, the approach is to not just supply a link to your work, but also to first write about any important pointers relevant to the discussion first, and then supply the link to your work to better aid it. Let&#39;s say there&#39;s a discussion going on the topic of &quot;What is Weight Initialization in Neural Nets?&quot; Here&#39;s how I would approach my comment: . A neural net can be viewed as a function with learnable parameters and those parameters are often referred to as weights and biases. Now, while starting the training of neural nets these parameters (typically the weights) are initialized in a number of different ways - sometimes, using constant values like 0’s and 1’s, sometimes with values sampled from some distribution (typically a uniform distribution or normal distribution), sometimes with other sophisticated schemes like Xavier Initialization. The performance of a neural net depends a lot on how its parameters are initialized when it is starting to train. Moreover, if we initialize it randomly for each run, it’s bound to be non-reproducible (almost) and even not-so-performant too. On the other hand, if we initialize it with constant values, it might take way too long to converge. With that, we also eliminate the beauty of randomness which in turn gives a neural net the power to reach covergence quicker using gradient-based learning. We clearly need a better way to initialize it. Careful initialization of weights helps us to train them better. To know more, please follow this article of mine. . Well, that&#39;s it for now. I hope it proves to be useful for you. Please provide any suggestions you may have via the comments. I am thankful to Alessio of FloydHub for sharing these tips with me. .",
            "url": "https://sayak.dev/blogs/sharing/2020/04/20/sharing-work-effectively.html",
            "relUrl": "/blogs/sharing/2020/04/20/sharing-work-effectively.html",
            "date": " • Apr 20, 2020"
        }
        
    
  
    
        ,"post9": {
            "title": "Embedding an image preprocessing function in a `tf.keras` model",
            "content": "In this tutorial, we are going to see how to embed a simple image preprocessing function within a trained model (tf.keras) while exporting it for serving. This is a useful feature to have because it can help us reduce a lot of boilerplate code needed while using any model for serving purposes. With this capability, you get a lot more flexibility and modularity to your model. . Note: At the time of writing this post, layers under tf.keras.layers.experimental.preprocessing were fairly new. But with time, they have matured enough and I encourage the usage of these layers inside TensorFlow/Keras models. . Data loading, preprocessing, and visualization . To keep things simple we will be using the FashionMNIST dataset. Note that these techniques can easily be applied to more complex models as well (with some limitation). . We are not going to preprocess the images before hand. We will let the model do it. . # Load data (x_train, y_train), (x_test, y_test) = tf.keras.datasets.fashion_mnist.load_data() . # Class labels (don&#39;t change the order) CLASSES = [&quot;T-shirt/top&quot;, &quot;Trouser&quot;, &quot;Pullover&quot;, &quot;Dress&quot;, &quot;Coat&quot;, &quot;Sandal&quot;, &quot;Shirt&quot;, &quot;Sneaker&quot;, &quot;Bag&quot;, &quot;Ankle boot&quot;] . # Show a few examples from the train set plt.figure(figsize=(10,10)) for i in range(25): plt.subplot(5,5,i+1) plt.xticks([]) plt.yticks([]) plt.grid(True) plt.imshow(x_train[i], cmap=plt.cm.binary) plt.xlabel(CLASSES[y_train[i]]) plt.show() . Model building and training . We are good to proceed towards building and training a neural network. We will first define a simple preprocessing function to scale the pixel values and then we will embed it into the model using a Lambda layer. You can replace this anything fancy you would want. . We will use a shallow network architecture so that we can train it quickly. . # Define the preprocessing function # We will embed it in the model later def preprocess_image(image_pixels): img = image_pixels / 255 return img # A humble model def get_training_model(): # Construct the model using the Functional API input_layer = tf.keras.layers.Input(shape=(28, 28), name=&quot;input_layer&quot;) preproc_layer = tf.keras.layers.Lambda(preprocess_image, name=&quot;lambda_layer&quot;)(input_layer) # Preprocessing function flatten = tf.keras.layers.Flatten()(preproc_layer) dense_1 = tf.keras.layers.Dense(128, activation=&quot;relu&quot;)(flatten) dropout = tf.keras.layers.Dropout(0.2)(dense_1) outputs = tf.keras.layers.Dense(len(CLASSES), activation=&quot;softmax&quot;)(dropout) # Create the model model = tf.keras.models.Model(input_layer, outputs) # Compile the model and return it model.compile(optimizer=&#39;adam&#39;, loss=&#39;sparse_categorical_crossentropy&#39;, metrics=[&#39;accuracy&#39;]) return model . # Topology of the model tf.keras.utils.plot_model(get_training_model(), show_shapes=True) . The Lambda layer is our preprocessing layer. . # Train the model for 10 epochs apparel_model = get_training_model() history = apparel_model.fit(x_train, y_train, validation_data=(x_test, y_test), epochs=10, batch_size=128) . Epoch 1/10 469/469 [==============================] - 2s 4ms/step - loss: 0.6004 - accuracy: 0.7937 - val_loss: 0.4682 - val_accuracy: 0.8347 Epoch 2/10 469/469 [==============================] - 2s 4ms/step - loss: 0.4246 - accuracy: 0.8495 - val_loss: 0.4089 - val_accuracy: 0.8521 Epoch 3/10 469/469 [==============================] - 2s 4ms/step - loss: 0.3795 - accuracy: 0.8642 - val_loss: 0.3928 - val_accuracy: 0.8564 Epoch 4/10 469/469 [==============================] - 2s 4ms/step - loss: 0.3576 - accuracy: 0.8711 - val_loss: 0.3632 - val_accuracy: 0.8687 Epoch 5/10 469/469 [==============================] - 2s 4ms/step - loss: 0.3407 - accuracy: 0.8762 - val_loss: 0.3593 - val_accuracy: 0.8688 Epoch 6/10 469/469 [==============================] - 2s 4ms/step - loss: 0.3294 - accuracy: 0.8788 - val_loss: 0.3532 - val_accuracy: 0.8721 Epoch 7/10 469/469 [==============================] - 2s 4ms/step - loss: 0.3165 - accuracy: 0.8846 - val_loss: 0.3609 - val_accuracy: 0.8685 Epoch 8/10 469/469 [==============================] - 2s 4ms/step - loss: 0.3084 - accuracy: 0.8859 - val_loss: 0.3503 - val_accuracy: 0.8701 Epoch 9/10 469/469 [==============================] - 2s 4ms/step - loss: 0.2982 - accuracy: 0.8915 - val_loss: 0.3560 - val_accuracy: 0.8713 Epoch 10/10 469/469 [==============================] - 2s 4ms/step - loss: 0.2886 - accuracy: 0.8929 - val_loss: 0.3381 - val_accuracy: 0.8776 . Now that we have a trained model, we can go ahead and export it and then we will see how to use it on new images for inference. . Sample test image and model export . We are getting close. Now that we have a trained model here are the things we would do from here: . Serialize a randomly selected image from the test set. | Export the model and parse model predictions. | . Let&#39;s go. . Step 1: Serializing a randomly selected image from the test set . # Select a random image from the test set for serialization sampe_test_img_id = np.random.choice(x_test.shape[0], 1) sampe_test_img = x_test[sampe_test_img_id].squeeze() # Remove the batch dimension sampe_test_img = (sampe_test_img * 255).astype(&quot;int32&quot;) # Scale back to integer # Verify image label and shape print(&quot;Image class: &quot;,CLASSES[y_test[int(sampe_test_img_id)]]) print(sampe_test_img.shape) . Image class: Ankle boot (28, 28) . #hide_output # Serialize the image cv2.imwrite(&quot;sample_image.png&quot;, sampe_test_img) . Note that while writing a grayscale image, OpenCV adds the channel dimension of 3 to it. We will need to handle carefully. . # Make sure the serialized image is good to go plt.imshow(plt.imread(&quot;sample_image.png&quot;), cmap=plt.cm.binary) plt.show() . Step 2: Model exporting and parsing predictions . Let&#39;s first serialize our model and load it. . # Serialize the model and load it apparel_model.save(&quot;apparel_model.h5&quot;) restored_model = tf.keras.models.load_model(&quot;apparel_model.h5&quot;) . WARNING:tensorflow:Error in loading the saved optimizer state. As a result, your model is starting with a freshly initialized optimizer. . This warning is not desirable. When the optimizer is loaded with a fresh state, the model predictions can be erroneous. So, to resolve this problem we will only be serializing the weights of the model with the save_weights() function. There can be other nuances like this when you work with Lambda layers and you can check this article out to know about them. . apparel_model.save_weights(&quot;apparel_model.h5&quot;) . We will now initialize a dummy model with the same architecture as the one we trained and we will then load the weights of our trained model into it. . restored_model = get_training_model() restored_model.load_weights(&quot;apparel_model.h5&quot;) . Now we should be good to go with the predictions part. First, let&#39;s load the image we serialized in step 1. As mentioned before, OpenCV adds 3-channels to grayscale images while saving them. We can take care of this issue with cv2.cvtColor(image_pixels, cv2.COLOR_BGR2GRAY). . # Load the image image_pixels = cv2.imread(&quot;sample_image.png&quot;) image_pixels = cv2.cvtColor(image_pixels, cv2.COLOR_BGR2GRAY) # Preview the image plt.imshow(image_pixels, cmap=plt.cm.binary) plt.show() . # Run inference and parse the prediction class_probabilities = restored_model.predict(np.expand_dims(image_pixels, 0))[0] print(&quot;Predicted &quot;,CLASSES[np.argmax(class_probabilities)]) . Predicted Ankle boot . We can see that it is working as expected. . # Load and *preprocess* data (x_train, y_train), (x_test, y_test) = tf.keras.datasets.fashion_mnist.load_data() x_train = x_train / 255 x_test = x_test / 255 . Taking it a step further with concrete functions and SavedModel . The SavedModel format is the standard serialization format in TensorFlow 2.x since it communicates very well with the entire TensorFlow ecosystem. Be it GCP AI Platform, be it tf.keras, be it TFLite, etc,, SavedModel format unifies the entire ecosystem. For serializing custom models (developed using subclassing) SavedModel would be needed as well. . In this section, let&#39;s see how can we do the same i.e. embed a preprocessing function inside a model so that it can be serialized in the SavedModel format. . Step 1: Create a sequential model without any preprocessing layer . def get_training_model_v2(): # Construct the model using the Functional API input_layer = tf.keras.layers.Input(shape=(28, 28), name=&quot;input_layer&quot;) flatten = tf.keras.layers.Flatten()(input_layer) dense_1 = tf.keras.layers.Dense(128, activation=&quot;relu&quot;)(flatten) dropout = tf.keras.layers.Dropout(0.2)(dense_1) outputs = tf.keras.layers.Dense(len(CLASSES), activation=&quot;softmax&quot;)(dropout) # Create the model model = tf.keras.models.Model(input_layer, outputs) # Compile the model and return it model.compile(optimizer=&quot;adam&quot;, loss=&quot;sparse_categorical_crossentropy&quot;, metrics=[&quot;accuracy&quot;]) return model . Step 2: Train it! . # Train the model for 10 epochs apparel_model_v2 = get_training_model_v2() history = apparel_model_v2.fit(x_train, y_train, validation_data=(x_test, y_test), epochs=10, batch_size=128) . Epoch 1/10 469/469 [==============================] - 2s 4ms/step - loss: 0.5995 - accuracy: 0.7914 - val_loss: 0.4549 - val_accuracy: 0.8347 Epoch 2/10 469/469 [==============================] - 2s 4ms/step - loss: 0.4200 - accuracy: 0.8501 - val_loss: 0.4094 - val_accuracy: 0.8520 Epoch 3/10 469/469 [==============================] - 2s 4ms/step - loss: 0.3823 - accuracy: 0.8616 - val_loss: 0.3831 - val_accuracy: 0.8635 Epoch 4/10 469/469 [==============================] - 2s 4ms/step - loss: 0.3575 - accuracy: 0.8713 - val_loss: 0.3896 - val_accuracy: 0.8563 Epoch 5/10 469/469 [==============================] - 2s 4ms/step - loss: 0.3405 - accuracy: 0.8758 - val_loss: 0.3569 - val_accuracy: 0.8720 Epoch 6/10 469/469 [==============================] - 2s 4ms/step - loss: 0.3249 - accuracy: 0.8813 - val_loss: 0.3490 - val_accuracy: 0.8733 Epoch 7/10 469/469 [==============================] - 2s 4ms/step - loss: 0.3176 - accuracy: 0.8840 - val_loss: 0.3480 - val_accuracy: 0.8735 Epoch 8/10 469/469 [==============================] - 2s 4ms/step - loss: 0.3055 - accuracy: 0.8878 - val_loss: 0.3355 - val_accuracy: 0.8809 Epoch 9/10 469/469 [==============================] - 2s 4ms/step - loss: 0.2971 - accuracy: 0.8914 - val_loss: 0.3331 - val_accuracy: 0.8792 Epoch 10/10 469/469 [==============================] - 2s 4ms/step - loss: 0.2905 - accuracy: 0.8920 - val_loss: 0.3344 - val_accuracy: 0.8808 . Step 3: SavedModel plunge . Okay! Now we are ready to the crux of the section. We will first create a custom model class (inherited from tf.keras.Model) and it will contain two things: . A model that is loaded with the weights of a trained model | A serving function that will contain the preprocessing function along with the necessary signature. | . # A custom class for serving class ExportModel(tf.keras.Model): def __init__(self, model): super().__init__(self) self.model = model @tf.function(input_signature=[tf.TensorSpec([None, 28, 28], dtype=tf.uint8)]) def my_serve(self, images): images = tf.cast(images, tf.float32) / 255 # pre-processing probabilities = self.model(images) # prediction from model class_index = tf.argmax(probabilities, axis=-1) # post-processing return {&quot;class_index&quot;: class_index} . my_serve is our serving function. You can see that is decorated with tf.function and the reason behind doing so is it allows us to embed an arbitrary function in a model&#39;s graph which can later be exported using the SavedModel format. . We can also see - input_signature=[tf.TensorSpec([None, 28, 28], dtype=tf.uint8)]. This is needed in order to indicate which part of the model&#39;s graph would be needed while serving. By specifying tf.TensorSpec([None, 28, 28], we instruct the function that the inputs should respect this shape - [None, 28, 28] and the dtype argument is self-explanatory. . We will get to why the return type of the function is done in such a way - {&quot;class_index&quot;: class_index} in a moment. . If you are interested to know more using SavedModel and different serialization options that come with it, be sure to check this tutorial out. . Step 4: Instantiate a dummy model and set its weights . # Set the weights of this dummy model to the weights of the model we trained restored_model = get_training_model_v2() restored_model.set_weights(apparel_model_v2.get_weights()) . Step 5: Export the model and run inference . Now, to serialize the model in the SavedModel format we will make use of tf.saved_model.save. It can automatically determine which input signature to use for serving for most of the models if the details are available. However, in our case, it won&#39;t be able to do so. So, we will need to explicitly indicate which function to use as the signature while serving. . export_path = &quot;/content/saved_model/1/&quot; tf.keras.backend.set_learning_phase(0) # Make sure no weight update happens serving_model = ExportModel(restored_model) # Instantiate a model with the preprocessing function tf.saved_model.save(serving_model, export_path, signatures={&#39;serving_default&#39;: serving_model.my_serve}) . WARNING:tensorflow:Skipping full serialization of Keras layer &lt;__main__.ExportModel object at 0x7f4096b7b358&gt;, because it is not built. WARNING:tensorflow:From /usr/local/lib/python3.6/dist-packages/tensorflow/python/ops/resource_variable_ops.py:1817: calling BaseResourceVariable.__init__ (from tensorflow.python.ops.resource_variable_ops) with constraint is deprecated and will be removed in a future version. Instructions for updating: If using Keras pass *_constraint arguments to layers. INFO:tensorflow:Assets written to: /content/saved_model/1/assets . By specifying &#39;serving_default&#39;: serving_model.my_serve we instructed tf.saved_model.save about which signature to use for serving. Now if we inspect what all were saved, things should seem consistent. For this we are going to use the saved_model_cli command-line interpreter. . !saved_model_cli show --dir /content/saved_model/1 --tag_set serve --signature_def serving_default . The given SavedModel SignatureDef contains the following input(s): inputs[&#39;images&#39;] tensor_info: dtype: DT_UINT8 shape: (-1, 28, 28) name: serving_default_images:0 The given SavedModel SignatureDef contains the following output(s): outputs[&#39;class_index&#39;] tensor_info: dtype: DT_INT64 shape: (-1) name: StatefulPartitionedCall:0 Method name is: tensorflow/serving/predict . So, we can see that the configuration that is expected from the inputs and the outputs of the serialized model is consistent with what we had instructed. We returned the outputs in form a dictionary (namely class_index) in my_serve and we can see that as well. . We can also do the inspection in Pythonic ways. . loaded = tf.saved_model.load(&quot;/content/saved_model/1/&quot;) print(list(loaded.signatures.keys())) # This signature will be used while serving . [&#39;serving_default&#39;] . # Output configuration infer = loaded.signatures[&quot;serving_default&quot;] print(infer.structured_outputs) . {&#39;class_index&#39;: TensorSpec(shape=(None,), dtype=tf.int64, name=&#39;class_index&#39;)} . Let&#39;s finally run the inference! . # Load the sample image image_pixels = cv2.imread(&quot;sample_image.png&quot;) image_pixels = cv2.cvtColor(image_pixels, cv2.COLOR_BGR2GRAY) . # Run inference CLASSES[infer(tf.constant(image_pixels))[&quot;class_index&quot;].numpy()[0]] . &#39;Ankle boot&#39; . We can see that the prediction is correct in this case as well. So, when we ran infer = loaded.signatures[&quot;serving_default&quot;] we essentially loaded a concrete function i.e. we loaded my_serve. Remember we assigned the value of serving_default in the beginning of this section? . With infer(tf.constant(image_pixels)) we are simply running our input image through the concrete function and we are parsing the output from the dictionary (class_index being the key) it returns . . References . MNIST on TPU (Tensor Processing Unit) or GPU using tf.Keras and tf.data.Dataset | Using the SavedModel format | .",
            "url": "https://sayak.dev/tf.keras/preprocessing/2020/04/13/embedding-image-preprocessing-functions.html",
            "relUrl": "/tf.keras/preprocessing/2020/04/13/embedding-image-preprocessing-functions.html",
            "date": " • Apr 13, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "I am primarily interested in image recognition and generation tasks which is what my professional work also requires. I am also interested in other areas of Deep Learning such as model optimization, semi-supervision, self-supervision, and model robustness. I enjoy implementing research ideas, sometimes incorporating them in practical applications, and communicating my implementation details through articles. . I advocate for highly readable and self-contained code. Python is what I primarily use for programming. I am proficient in TensorFlow and a beginner in PyTorch. I usually train models on Google Cloud Platform / Colaboratory / Kaggle facilitating TPUs when required. . I have a flair for open-source initiatives. In particular, I have made contributions to TensorFlow Hub, Keras Examples, TensorFlow Addons, and Neural Structured Learning. Off the work, I like writing technical articles, working on applied Machine Learning ideas, and giving talks at developer meetups and conferences. . For my community contributions and innovative projects, the Intel Software Innovator Program recognized me as one of their top innovators in 2019. For my open-source contributions, I received the Google Open Source Peer Bonus Award in 2020 and 2021, TensorFlow Top Contributor Award in 2021. . | | | | . Timeline: . Machine Learning Engineer, Carted (June 2021 - Present) | Deep Learning Associate, PyImageSearch (June 2019 - June 2021) | Data Science Instructor, DataCamp (August 2018 - June 2019) (on contract) | Software Engineer, TCS Research and Innovation (January 2018 - August 2018) | Software Engineer, Tata Consultancy Services Limited (July 2017 - January 2018) | Intern, CareerIn (Dec, 2016 - Feb, 2017) | . Badges I proudly endorse: . . An honour to be their son 🙂 . Tapas Kumar Paul | Baby Paul | .",
          "url": "https://sayak.dev/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  
      ,"page2": {
          "title": "Authoring",
          "content": "Co-authored a book Hands-On Python Deep Learning for the Web with Anubhav Singh. . Authored the following liveProjects with Manning: . Use Machine Learning to Detect Phishing Websites | Summarize News Articles with NLP and TensorFlow (with Souradip Chakraborty) | . Authored two DataCamp Projects (Predicting Credit Card Approvals and Analyze International Debt Statistics) and a DataCamp Practice Pool on Advanced Deep Learning with Keras. . Below are the blogs, articles, and tutorials I have written on Data Science, Machine Learning and more. I am fortunate enough to collaborate with amazing folks from all around the globe. I am grateful to the ML-DGE Program that provides me with Google Cloud Platform credits which I use to run various experiments for my own curiosity as well as the blog posts. . Keras . MixUp augmentation for image classification | RandAugment for Image Classification for Improved Robustness | Self-supervised contrastive learning with SimSiam | Consistency Training with Supervision | Learning to Resize in Computer Vision | Keypoint Detection with Transfer Learning | Video Classification with a CNN-RNN Architecture | Video Classification with Transformers | Semi-supervision and domain adaptation with AdaMatch | Compact Convolutional Transformers | Conditional GAN | Vector-Quantized Variational Autoencoders | Knowledge distillation recipes | Multimodal entailment | Handwriting recognition (joint work with Aakash Kumar Nain) | Near-duplicate image search | Large-scale multi-label text classification (joint work with Soumik Rakshit) | FixRes: Fixing train-test resolution discrepancy | Image classification with ConvMixer | MobileViT: A mobile-friendly Transformer-based model for image classification | Point cloud segmentation with PointNet (joint work with Soumik Rakshit) | Masked image modeling with Autoencoders (joint work with Aritra Roy Gosthipaty) | . Datacamp . KMeans clustering with scikit-learn | Demystifying Crucial Statistics in Python 1 | Turning Machine Learning Models into APIs in Python 2 | Essentials of Linear Regression in Python 3 | Simplifying Sentiment Analysis in Python | Introduction to Indexing in SQL | Understanding Recursive Functions in Python | Beginner’s Guide to Google’s Vision API in Pytho | Beginner’s Guide to PostgreSQL | Managing Databases in PostgreSQL | Working with Spreadsheets in SQL | Installing PostgreSQL on Windows and Mac OS X | Using Order By Keyword in SQL | Introduction to Alter Table Statement in SQL | SQLite in Python | Introduction to Where Clause in SQL | Introduction to SQL Joins | 10 command-line utilities in PostgreSQL | CASE Statements in PostgreSQL | Cleaning Data in SQL | Materialized Views in PostgreSQL | Argument Parsing in Python | Ten Important Updates from TensorFlow 2.0 | Implementing Neural Style Transfer using TensorFlow 2.0 | TensorFlow 2.0 Case Study | . FloydHub . Introduction to Anomaly Detection in Python | Introduction to K-Means Clustering in Python with scikit-learn | An introduction to Q-Learning: Reinforcement Learning | How to plan and execute your ML and DL projects | Becoming One With the Data 4 | Training Neural Nets: a Hacker’s Perspective | . Weights and Biases . Running Hyperparameter Sweeps to Pick the Best Model | arXiv Search: Generating Tags from Paper Titles | How to Use GCP with Weights &amp; Biases | Mixed precision training with tf.keras | Customizing Training Loops in TensorFlow 2.0 | Bayesian Hyperparameter Optimization - A Primer | Visualize models in TensorBoard with Weights and Biases | The effects of weight initialization on neural nets | Introduction to image inpainting with deep learning (joint work with Ayush Thakur) | Reproducible Models with W&amp;B | EvoNorm layers in TensorFlow 2 | A Tale of Model Quantization in TF Lite | Towards self-supervised image understanding with SimCLR | The Power of Random Features of a CNN | Plotting top loss images while training models (joint work with Tulasi) | Improving Image Classifiers with Supervised Contrastive Learning (joint work with Sweta Shaw) | Model Pruning in Deep Learning | Understanding the Effectivity of Ensembles in Deep Learning (joint work with Ayush Thakur) | An Introduction to Adversarial Examples in Deep Learning 5 | Unsupervised Visual Representation Learning with SwAV (joint work with Ayush Thakur) | Distilling Knowledge in Neural Networks | . Google Cloud Platform . Streamline your ML training workflow with Vertex AI (joint work with Karl Weinmeister of Google) | Image search with natural language queries (joint work with Chansung Park) | Dual deployments on Vertex AI (joint work with Chansung Park) 6 | Model training as a CI/CD system - Part I, Part II (joint work with Chansung Park) | . Others . Lessons learned from a Deep Learning Hackathon | “Reparameterization” trick in Variational Autoencoders | Your First Machine Learning Project: Q and A with Sayak Paul, Google Developer Expert (GDE) in Machine Learning (Ep. 4) | AMA with Sayak Paul - Hacktoberfest’19 | Predicting the publisher’s name from an article: A case study 7 | GDE Journey — Sayak Paul | Multi-part tutorial series on Selfie2Anime with TFLite (joint work with ML-GDE Margaret Maynard-Reid) - Part I, Part II, Part III | How to Create a Cartoonizer with TensorFlow Lite (joint work with ML-GDE Margaret Maynard-Reid) | Multi-part tutorial series on Create Artistic Effect by Stylizing Image Background (joint work with ML-GDEs Margaret Maynard-Reid and George Soloupis) - Part I, Part II, Part III 8 | TensorFlow Addons Optimizers: CyclicalLearningRate | Graph regularization for image classification using synthesized graphs 9 | . This article got featured in “Python Top 10 Articles for the Past Month (v.Oct 2018)” and secured a rank of 4. &#8617; . | This article got featured in “Machine Learning Top 10 Articles for the Past Month (v.Nov 2018)” and secured a rank of 9. &#8617; . | This article got featured in “Python Top 10 Articles for the Past Month (v.Dec 2018)” and secured a rank of 10. &#8617; . | Featured in Sebastian Ruder’s monthly newsletter. &#8617; . | This one ranked eighth at a blogging competition. &#8617; . | This project got the #TFCommunitySpotlight award. &#8617; . | This one won the ML GDE Dev Challenge. &#8617; . | This project got the #TFCommunitySpotlight award. &#8617; . | In collaboration with the Neural Structured Learning team at Google. &#8617; . |",
          "url": "https://sayak.dev/authoring/",
          "relUrl": "/authoring/",
          "date": ""
      }
      
  

  
      ,"page3": {
          "title": "Education",
          "content": "(The formal ones may be) . B.Tech in IT from Netaji Subhash Engineering College (2013 - 17) (Final year dissertation: A CFS–DNN-Based Intrusion Detection System) | High School from Jadavpur Vidyapith (PCMC) (2005 - 13) | Courses/certifications relevant to my subject of interest: . Data Scientist with Python Track (DataCamp) | Data Analyst with Python Track (DataCamp) | Deep Learning Specialization (Coursera) | Advanced Machine Learning with TensorFlow on Google Cloud Platform (Coursera) | TensorFlow in Practice Specialization (Coursera) | TensorFlow: Data and Deployment Specialization (Coursera) | Generative Adversarial Networks (GANs) (Coursera) | Natural Language Processing (Coursera) | TensorFlow Developer Certification | Mathematics for Machine Learning (Coursera) | Machine Learning Engineering for Production (MLOps) (Coursera) | . | .",
          "url": "https://sayak.dev/education/",
          "relUrl": "/education/",
          "date": ""
      }
      
  

  

  
      ,"page5": {
          "title": "Interviews",
          "content": "The purpose of conducting these interviews is to mainly get insights about the real-world project experiences, perspectives on learning new things, some fun facts and thereby enriching the communities in the process. I sincerely thank the interviewees for taking the time out from their busy schedules and for agreeing to do these interviews. Here are the interviews I have done so far - . An interview with Robert Crowe, Developer Advocate (TensorFlow) at Google | An interview with Snehasis Banerjee, Scientist at TCS Research and Innovation | An interview with Abhishek Kumar, Senior Manager, Data Science at Publicis Sapient | An interview with Laurence Moroney, Developer Advocate at Google | An interview with Karl Fezer, AI Ecosystem Evangelist at Arm | An interview with Dan Becker, Team Lead of Kaggle Learn &amp; Product Lead of Kaggle Kernels | An interview with Rajarshee Mitra, Data Scientist at Microsoft | An interview with Alessio, Lead Data Scientist at FloydHub | An interview with Joel Grus, Research Engineer at Allen Institute for Artificial Intelligence | An interview with Josh Tobin, Research Scientist at OpenAI | An interview with Andrew Ferlitsch, Developer Program Engineer at Google | An interview with Shalini De Mello, Principal Research Scientist at NVIDIA | An interview with Rahul Agrawal, Principal Machine Learning Manager at AI and Research, Microsoft | An interview with Aakash Nain, Research Engineer at Ola | An interview with Xander Steenbrugge, Machine Learning Researcher &amp; YouTuber at “Arxiv Insights” | An interview with Ines Montani, Co-founder at Explosion | An interview with Girish Palshikar, Principal Scientist at TCS Research and Innovation | An interview with Christoph Molnar, Interpretable Machine Learning Researcher | An interview with Leslie Smith, Senior Research Scientist at U.S. Naval Research Laboratory | An interview with Arindam Pal, Senior Research Scientist at CSIRO | An interview with Ankur Patel, Vice President of Data Science at 7Park Data | An interview with Max Pumperla, Deep Learning Engineer at Skymind | An interview with Abhishek Thakur, Data Scientist, and Kaggle 3x Grandmaster | An interview with Dmytro Mishkin, Computer Vision Researcher | An interview with Ellick Chan, Head of University Relations and Research — Intel AI Academy | An interview with Thomas Wolf, Chief Science Officer at Hugging Face | An interview with Dat Tran, Head of AI at Axel Springer AI | An interview with Daniel Seita, Ph.D. student at UC, Berkeley | An interview with Vladimir Iglovikov, Senior Computer Vision Engineer at Lyft | An interview with Hamel Husain, Staff Machine Learning Engineer at GitHub | An interview with Patrick Hall, Principal Scientist at bnh.ai and Advisor to H2O.ai | An interview with Colin Raffel, Research Scientist at Google | An interview with Niki Parmar, Senior Research Scientist at Google Brain | An interview with Alexander (Sasha) Rush, Associate Professor at Cornell University | An interview with Vincent Sitzmann, Postdoctoral Researcher at MIT | An interview with Dan Hendrycks, Ph.D. student at UC Berkeley | . I have had an amazing time interviewing these incredible folks and I am grateful to them. For other competing priorities, I am discontinuing the series for an indefinite period. If you enjoy reading through interviews like these, you might want to check out the Machine Learning Street Talk podcast on YouTube. .",
          "url": "https://sayak.dev/interviews/",
          "relUrl": "/interviews/",
          "date": ""
      }
      
  

  
      ,"page6": {
          "title": "Research",
          "content": "I am interested in a number of topics pertaining to Deep Learning: . Self-supervised and semi-supervised representation learning | Model robustness | Model optimization | . My Google Scholar profile is available here. . Selected publications and preprints: . Gupta J., Paul S., Ghosh A. (2019) A Novel Transfer Learning-Based Missing Value Imputation on Discipline Diverse Real Test Datasets—A Comparative Study with Different Machine Learning Algorithms. In: Abraham A., Dutta P., Mandal J., Bhattacharya A., Dutta S. (eds) Emerging Technologies in Data Mining and Information Security. Advances in Intelligent Systems and Computing, vol 814. Springer, Singapore. | Saptarshi Sengupta, Sanchita Basak, Pallabi Saikia, Sayak Paul, Vasilios Tsalavoutis, Frederick Atiah, Vadlamani Ravi, Alan Peters, A review of deep learning with special emphasis on architectures, applications and recent trends, Knowledge-Based Systems, Volume 194, 2020, 105596, ISSN 0950-7051. | S. Chakraborty*, A. R. Gosthipaty* and S. Paul*, “G-SimCLR: Self-Supervised Contrastive Learning with Guided Projection via Pseudo Labelling,” 2020 International Conference on Data Mining Workshops (ICDMW), Sorrento, Italy, 2020, pp. 912-916, doi: 10.1109/ICDMW51313.2020.00131. arXiv copy of the paper is available here. *equal contribution. | Andrey Ignatov, Grigory Malivenko, Radu Timofte, Sheng Chen, Xin Xia, Zhaoyan Liu, Yuwei Zhang, Feng Zhu, Jiashi Li, Xuefeng Xiao, Yuan Tian, Xinglong Wu, Christos Kyrkou, Yixin Chen, Zexin Zhang, Yunbo Peng, Yue Lin, Saikat Dutta, Sourya Dipta Das, Nisarg A. Shah, Himanshu Kumar, Chao Ge, Pei-Lin Wu, Jin-Hua Du, Andrew Batutin, Juan Pablo Federico, Konrad Lyda, Levon Khojoyan, Abhishek Thanki*, Sayak Paul*, and Shahid Siddiqui. “Fast and Accurate Quantized Camera Scene Detection on Smartphones, Mobile AI 2021 Challenge: Report.” (CVPR 2021)1 ArXiv:2105.08819 [Cs, Eess], May 2021. arXiv.org, https://arxiv.org/abs/2105.08819. *equal contribution. | Sayak Paul*, and Siddha Ganju*. “Flood Segmentation on Sentinel-1 SAR Imagery with Semi-Supervised Learning.”2 ArXiv:2105.07581 [Cs], July 2021. arXiv.org, https://arxiv.org/abs/2107.08369. *equal contribution. This work was also featured by NVIDIA in this blog post. This work made it to the following NeurIPS 2021 workshops: AI for Science: Mind the Gaps, Tackling Climate Change with Machine Learning, Women in ML, and Machine Learning and the Physical Sciences. | Sayak Paul*, and Pin-Yu Chen*. “Vision Transformers Are Robust Learners.” ArXiv:2105.07581 [Cs], May 2021. arXiv.org, https://arxiv.org/abs/2105.07581. *equal contribution. | . Others . Tutorial organizer and presenter: Practical Adversarial Robustness in Deep Learning: Problems and Solutions (CVPR 2021) | Reviewer: Uncertainty &amp; Robustness in Deep Learning workshop (ICML 2021) | Released a dataset for large-scale multi-label text classification (joint work with Soumik Rakshit) | . This is our report for this CVPR 2021 competition. The report contains solution approaches from the teams (including ours) that got the top positions. &#8617; . | This paper demonstrates the solution approach our team took to finish as the first runners-up at this competition organized by the NASA Impact team. It got accepted for an oral presentation at the ESA-ECMWF workshop 2021. &#8617; . |",
          "url": "https://sayak.dev/research/",
          "relUrl": "/research/",
          "date": ""
      }
      
  

  
  

  
  

  

  
      ,"page10": {
          "title": "Talks/Seminars/Workshops",
          "content": "I love to attend developer meetups, conferences, workshops and learn from them as much as I can. I sometimes talk on a range of topics that I love the most. All the slides of my talks/sessions can be found below. . Given by me: . Presented our paper A CFS–DNN-Based Intrusion Detection System at International Conference on Communication Devices and Networking, Sikkim Manipal Institute of Technology, Sikkim, June 3, 2017. | Presented our paper A Comparative Study of Different Ensemble Learning Techniques Using Wisconsin Breast Cancer Dataset, at International Conference on Computer, Electrical &amp; Communication Engineering, Techno India University, Kolkata, December 23, 2017. | Co-presented our paper A Novel Transfer Learning-Based Missing Value Imputation on Discipline Diverse Real Test Datasets—A Comparative Study with Different Machine Learning Algorithms at International Conference on Emerging Technologies in Data Mining and Information Security, University of Engineering and Management, Kolkata, February 23, 2018. | Spoke on Cyclical Learning Rates for training Neural Nets at DevFest Kolkata, November 3, 2018. | Conducted a hack-session on Cyclical Learning Rates at DataHack Summit (organized by Analytics Vidhya), Bangalore, November 23, 2018. | Delivered talks on Introduction to BigQuery at GDG Kolkata Cloud Study Jam (Academy of Technology), Google Cloud Next ‘19 Extended - Kolkata on April 12 and April 19, 2019 respectively. | Conducted a session on Ten Updates Introduced in TensorFlow 2.0 along with a short quiz at Google I/O Extended 2019, Kolkata, May 11, 2019. | Conducted a session on Training neural nets: A methodical approach at ML/AR Developer Day organized by GDG Kolkata and DSC HIT (May 30, 2019). Conducted the same session but in a more detailed manner at ML With The Experts - GDG Kolkata Meetup (July 7, 2019). | . | Spoke at Google I/O Extended 2019, Bhubaneswar on Ten Updates Introduced in TensorFlow 2.0, June 9, 2019. Also shared a few opportunities with the students (link to the Opportunities’ deck). | Spoke at DevFest Kolkata 2019 about how to approach the process of model deployment, August 3, 2019. My talk was titled Connecting Flutter with TensorFlow 2.0. Link to the slides, video and the GitHub repository. | Spoke at DevFest Jaipur 2019 (September 08, 2019) on Structuring Machine Learning Projects. Remotely presented on this topic at DevFest Izmir 2019 (November 23, 2019). Here’s the modified deck. Here’s a recording of the session. | . | Spoke at Explore ML Academy on Problem Framing and How to find data set and fairness practices, September 14, 2019, Hyderabad. | Spoke at DevFest Bhubaneswar 2019 (September 22, 2019) on The Human Loop in Machine Learning. | Spoke at DevFest Goa 2019 (September 29, 2019) on Training Neural Nets: a Hacker’s Perspective. Spoke at Class III of Launchpad Accelerator India (October 16, 2019), Bangalore on an extended version of the same topic. Deck: http://bit.ly/LPA_3. | Remotely presented on this topic at DevFest Warsaw &amp; Radzymin 2019 (December 7, 2019). | . | Presented my work on Blood Cell Detection using TensorFlow Object Detection API at TensorFlow Roadshow, Bangalore (October 01, 2019). Deck: http://bit.ly/tf-roadshow-sayak. | Remotely presented my work on Predicting Publisher’s Names from Hackernews Article Titles at Global GDE Summit (October 26, 2019). Video available here (Courtesy: Akshay Bahadur). Deck: http://bit.ly/GDESummit19. | Remotely presented at Machine Learning Weekend, Turkey on Building data pipelines with tf.data (November 3, 2019). | Presented at Kaggle Days Mumbai on On the learning dynamics of neural nets (November 30, 2019). | Conducted a workshop on Applied Deep Learning using TensorFlow 2.0 and GCP (includes topics like data pipeline optimization, cyclical learning rates, mixed-precision training and so on) at Launchpad India Accelerator Bootcamp (December 12 - 13, 2019). Content available here: http://bit.ly/mlb-code-sayak. | Spoke at DevLoop on Your first machine learning project, Ganpat University, Gujrat, India (January 04, 2020). Deck: http://bit.ly/dloop20. I have spoken about this topic at multiple occasions. A session recording is available here. | Spoke at Improving machine learning model on Weights and Biases for better machine learning, Bangalore (February 08, 2020). Deck: http://bit.ly/blr-wb. | Spoke at Sigma 2020 on Machine Learning: For the Community by the Community, Kolkata (February 12, 2020). | Spoke at MENA Digital Days 2020 on Building data pipelines with tf.data. Deck here, session video here. | Spoke for GDG Goa at an online event on Hello, TensorFlow. Deck here, session here. | Spoke for GDG Pune and WTM Pune on Doing more with TensorFlow Lite, April 26, 2020. A session recording is available here (it was for the Deep Learning Salon hosted by Weights and Biases). | Spoke for Global AI Hub, Turkey on Gotchas of Transfer Learning for Image Classification, May 01, 2020. A recording of the session is available here. | Spoke on TensorFlow Hub: Models, Models, and Models for TFUG Hyderabad on May 03, 2020. Deck: http://bit.ly/tf-hub. A recording of the session is available here. | Participated in an ML fire-side chat hosted by Aniedi to speak to the developers of African regions. Recording is available here (May 30, 2020). | Spoke at Pie and AI Kolkata on Becoming One with the Data. Deck here &amp; session recording here (May 31, 2020). | Spoke on Model Optimization 101 for TFUG Thrissur. Deck here (June 07, 2020). A recording on the same topic from a different event is available here. I have also presented this at Google for Startups Accelerator India (GoogleDevsIN tweet). A recording of that session is available here. | Spoke to Tim Scarfe, Connor Shorten, and Yannic Kilcher at the Machine Learning Street Talk: https://bit.ly/ml-st-sayak. | Spoke on A few good stuff in TensorFlow Lite for GDG Berlin (July 16, 2020). Deck is available here and a recording is available here. | Spoke to Mathilde Caron (Research Assistant at Facebook AI), with Ayush Thakur, Tim Scarfe, and Yannic Kilcher at the Machine Learning Street Talk: http://bit.ly/mlst-mathilde. | Spoke on GitHub Actions for Machine Learning at Global AI On Tour Mumbai (September 27, 2020). Deck is available here. | Spoke on The Maker Philosophy with ML APIs at Mindhack Summit (October 12, 2020). Deck is available here. | Spoke on Adversarial Examples in Deep Learning at DevFest UK &amp; Ireland 2020 (October 17, 2020). Deck is available here. | Spoke to Sara Hooker (Google Brain), with Tim Scarfe, and Yannic Kilcher at the Machine Learning Street Talk: bit.ly/sara_mlst. | Spoke to Sanyam Bhutani (H2O.ai), with Tim Scarfe, Yannic Kilcher, and Alex Stenlake at the Machine Learning Street Talk: bit.ly/sanyam_mlst. | Took a workshop on Adversarial Robustness in Deep Learning with Dipanjan Sarkar at Deep Learning DevCon 2020 (October 29, 2020). The materials are available here - bit.ly/adv_learn. We presented this at Kshitij 2021 as well and here’s the recording. | Spoke on Demystifying Self-Supervised Learning for Visual Recognition at SciPy Japan 2020 (October 30, 2020). Deck is available here - bit.ly/scipy-sp. Session recording is available here. | Spoke to Santosh on Demystifying ML and AI for beginners at his podcast Tech Talks With Santosh: https://youtu.be/BhLQN-XIO04 (November 07, 2020). | Spoke with Simon Kornblith (Google Brain) at the Machine Learning Street Talk (with Tim Scarfe and Yannic Kilcher). | Spoke with Lena Voita (University of Edinburgh and University of Amsterdam) at the Machine Learning Street Talk (with Tim Scarfe and Yannic Kilcher). | Spoke with Hadi Salman (MIT) at the Machine Learning Street Talk (with Tim Scarfe and Yannic Kilcher). | Spoke with Ishan Misra (Facebook AI Research) at the Machine Learning Street Talk (with Tim Scarfe and Yannic Kilcher). | Spoke on Key Trends of Computer Vision 2021 (June 09, 2021). Deck is available here. A session recording is available here. A blog post summary by Benedict Neo is available here. I have also presented this at Takshak’21, Techfest of ISM Dhanbad. | Vertex AI for Easier Model Deployments at Google for Startups Accelerator Class 5 (August 28, 2021). Deck is available here. A recording is available here. | Enabling Possibilities with Open-Source in Machine Learning at DevFest India 2021 (October 24, 2021). My deck is available here. A recording is available here. | Citizen Scientists Tackling Devastating Floods and Disaster Relief with Semi-supervised Deep Learning at NVIDIA GTC 2021 (November 09, 2021). This is based on our work on using semi-supervision for segmenting flood regions. | . Co-organized by me: . DevFest Kolkata, August 3, 2019. | TensorFlow All-Around Kolkata, August 31, 2019. | Let’s Build, January 4, 2020. | Kolkata Kreate, February 29, 2020. | TFUG India Summit, September 3 - 6, 2020. | . Note: If you are interested to invite me as a speaker for your event, please get in touch by dropping an email at spsayakpaul@gmail.com. If you are interested in having me submit a CFP first, that is absolutely fine! Please don’t hesitate to ask that. .",
          "url": "https://sayak.dev/talksseminarsworkshops/",
          "relUrl": "/talksseminarsworkshops/",
          "date": ""
      }
      
  

  
      ,"page11": {
          "title": "XYZ",
          "content": "Taught under-privileged children and managed operations for a TCS-CSR initiative called H20 (Helping Hand Organization) | Moderator of the Artificial Intelligence channel of Campus Commune | Book reviewer for Manning Publications Co | Co-organizer of GDG Kolkata (2019 - 2021) | Organizer of TensorFlow User Group Kolkata (2020 - 2021) | Mentorship: Launchpad Women Entrepreneurs | Explore ML Academy, Hyderabad | AI Hack Tunisia | Class III (2019) of Launchpad Accelerator India (Tweet by GoogleDevsIN) | Google Code-in for TensorFlow through December, 2019 - January 2020 (Certificate) | Build For Digital India Bootcamps through January 2020 - February 2020 (Tweet by GoogleDevsIN) | Explore ML Bootcamp, Hyderabad (Tweet by GoogleDevsIN) | Mentored at Google for Startups India Accelerator 2020, 2021 | Mentored for TensorFlow at Google Summer of Code 2021 (GSoC). Students: Aditya Kane and Vasudev Gupta. Here’s a related blog post from TensorFlow. | . | Community services: Program committe member, Uncertainty &amp; Robustness in Deep Learning Workshop (ICML 2021) | Program committe member, ML Conf EU 2020 | . | Awards and recognition: Recipient of the Google Open Source Peer Bonus Award (2020 and 2021). Here’s a related blog post (from the official Google Open Source Blog) jotting down the experiences that led to this honor. | Led our team at PyImageSearch to Top 10 at this CVPR 2021 competition. | Finished 2nd (with Siddha Ganju) at this competition organized by the NASA Impact team (Certificate). | Received the #TFCommunitySpotlight award four times for projects with varying use-cases, tooling, and motivation. Details in the following tweets by TensorFlow: Tweet 1, Tweet 2, Tweet 3, and Tweet 4. | Ranked 8 at Applied Roots Blogathon 2021. | Recipient of the Intel Top Innovator Award (2019). | Became a Google Cloud Innovator (Champion tier). | Awarded as the Top Regional Contributor from India for TensorFlow, 2021. Blog post and Tweet from TensorFlow. | . | . Non-tech: . I love listening to all genres of music. A guitar player myself. Have played in a band Behest from 2013 to 2017. | I love watching TV serials also (Narcos, Suits, Fringe, Seal Team, Ozark being all-time favorites). | .",
          "url": "https://sayak.dev/xyz/",
          "relUrl": "/xyz/",
          "date": ""
      }
      
  

  
  

  
  

  
  

  
      ,"page15": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://sayak.dev/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}